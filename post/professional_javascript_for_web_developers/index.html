<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>《JavaScript高级程序设计》(第4版) 阅读记录 - Single Long</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Single Long" />
  <meta name="description" content="1、什么是JavaScript？ 简史 随着网络的普及，对客户端脚本语言的需求逐渐增长。 当时，即使网页的大小和复杂性不断增加，大多数Intern" />

  <meta name="keywords" content="Single Long, Blog" />






<meta name="generator" content="Hugo 0.74.3" />


<link rel="canonical" href="https://slkyrim.github.io/post/professional_javascript_for_web_developers/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="《JavaScript高级程序设计》(第4版) 阅读记录" />
<meta property="og:description" content="1、什么是JavaScript？ 简史 随着网络的普及，对客户端脚本语言的需求逐渐增长。 当时，即使网页的大小和复杂性不断增加，大多数Intern" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://slkyrim.github.io/post/professional_javascript_for_web_developers/" />
<meta property="article:published_time" content="2020-10-21T11:24:03+08:00" />
<meta property="article:modified_time" content="2020-10-21T11:24:03+08:00" />
<meta itemprop="name" content="《JavaScript高级程序设计》(第4版) 阅读记录">
<meta itemprop="description" content="1、什么是JavaScript？ 简史 随着网络的普及，对客户端脚本语言的需求逐渐增长。 当时，即使网页的大小和复杂性不断增加，大多数Intern">
<meta itemprop="datePublished" content="2020-10-21T11:24:03+08:00" />
<meta itemprop="dateModified" content="2020-10-21T11:24:03+08:00" />
<meta itemprop="wordCount" content="26300">



<meta itemprop="keywords" content="JavaScript,English,英语,CopyTranslator," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《JavaScript高级程序设计》(第4版) 阅读记录"/>
<meta name="twitter:description" content="1、什么是JavaScript？ 简史 随着网络的普及，对客户端脚本语言的需求逐渐增长。 当时，即使网页的大小和复杂性不断增加，大多数Intern"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">龍</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      龍
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">《JavaScript高级程序设计》(第4版) 阅读记录</h1>
      
      <div class="post-meta">
        <time datetime="2020-10-21" class="post-time">
          2020-10-21
        </time>
        <div class="post-category">
            <a href="https://slkyrim.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/"> 技术书籍 </a>
            
          </div>
        <span class="more-meta"> 约 26300 字 </span>
          <span class="more-meta"> 预计阅读 53 分钟 </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1什么是javascript">1、什么是JavaScript？</a>
      <ul>
        <li><a href="#简史">简史</a></li>
        <li><a href="#javascript的实现">JAVASCRIPT的实现</a></li>
        <li><a href="#ecmascript">ECMAScript</a></li>
        <li><a href="#ecmascript版本">ECMAScript版本</a></li>
        <li><a href="#文档对象模型">文档对象模型</a></li>
        <li><a href="#为什么需要dom">为什么需要DOM</a></li>
        <li><a href="#dom级别">DOM级别</a></li>
        <li><a href="#浏览器对象模型">浏览器对象模型</a></li>
        <li><a href="#javascript版本">JAVASCRIPT版本</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
    <li><a href="#2html中的javascript">2、HTML中的JavaScript</a>
      <ul>
        <li><a href="#ltscriptgt元素">&lt;Script&gt;元素</a></li>
        <li><a href="#小结-1">小结</a></li>
      </ul>
    </li>
    <li><a href="#3语言基础">3、语言基础</a>
      <ul>
        <li><a href="#语法">语法</a></li>
        <li><a href="#区分大小写">区分大小写</a></li>
        <li><a href="#标识符">标识符</a></li>
        <li><a href="#注释">注释</a></li>
        <li><a href="#严格模式">严格模式</a></li>
        <li><a href="#陈述">陈述</a></li>
        <li><a href="#关键字和保留字">关键字和保留字</a></li>
        <li><a href="#变量">变量</a></li>
        <li><a href="#var关键字">“var”关键字</a></li>
        <li><a href="#var声明范围">var声明范围</a></li>
        <li><a href="#var声明提升">var声明提升</a></li>
        <li><a href="#let声明">“let”声明</a></li>
        <li><a href="#时间死区">时间死区</a></li>
        <li><a href="#全局声明">全局声明</a></li>
        <li><a href="#有条件的声明">有条件的声明</a></li>
        <li><a href="#循环中的let声明">循环中的let声明</a></li>
        <li><a href="#const声明">“const”声明</a></li>
        <li><a href="#声明样式和最佳做法">声明样式和最佳做法</a></li>
        <li><a href="#数据类型">数据类型</a></li>
        <li><a href="#小结-2">小结</a></li>
      </ul>
    </li>
    <li><a href="#4变量范围和内存">4、变量，范围和内存</a>
      <ul>
        <li><a href="#小结-3">小结</a></li>
      </ul>
    </li>
    <li><a href="#5基本引用类型">5、基本引用类型</a>
      <ul>
        <li><a href="#小结-4">小结</a></li>
      </ul>
    </li>
    <li><a href="#6集合引用类型">6、集合引用类型</a>
      <ul>
        <li><a href="#小结-5">小结</a></li>
      </ul>
    </li>
    <li><a href="#7迭代器和生成器">7、迭代器和生成器</a>
      <ul>
        <li><a href="#小结-6">小结</a></li>
      </ul>
    </li>
    <li><a href="#8对象类和面向对象的编程">8、对象，类和面向对象的编程</a>
      <ul>
        <li><a href="#小结-7">小结</a></li>
      </ul>
    </li>
    <li><a href="#9代理与反思">9、代理与反思</a>
      <ul>
        <li><a href="#小结-8">小结</a></li>
      </ul>
    </li>
    <li><a href="#10函数">10、函数</a>
      <ul>
        <li><a href="#小结-9">小结</a></li>
      </ul>
    </li>
    <li><a href="#11承诺和异步功能">11、承诺和异步功能</a>
      <ul>
        <li><a href="#小结-10">小结</a></li>
      </ul>
    </li>
    <li><a href="#12浏览器对象模型">12、浏览器对象模型</a>
      <ul>
        <li><a href="#小结-11">小结</a></li>
      </ul>
    </li>
    <li><a href="#13客户端检测">13、客户端检测</a>
      <ul>
        <li><a href="#小结-12">小结</a></li>
      </ul>
    </li>
    <li><a href="#14文档对象模型">14、文档对象模型</a>
      <ul>
        <li><a href="#小结-13">小结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="1什么是javascript">1、什么是JavaScript？</h2>
<h3 id="简史">简史</h3>
<p>随着网络的普及，对客户端脚本语言的需求逐渐增长。 当时，即使网页的大小和复杂性不断增加，大多数Internet用户仍通过28.8 kbps的调制解调器进行连接。 使用户感到痛苦的是，简单表单验证所需的服务器往返次数众多。 想象一下，填写表单，单击“提交”按钮，等待30秒钟进行处理，然后看到一条消息，提示您忘记填写必填字段。 当时处于技术创新前沿的Netscape开始认真考虑开发客户端脚本语言以处理简单处理的问题。</p>
<p>1995年，一位名叫Brendan Eich的Netscape开发人员开始为发布Netscape Navigator 2开发一种名为Mocha（后来更名为LiveScript）的脚本语言。其目的是要在浏览器和服务器上同时使用它。 称为LiveWire。</p>
<p>Netscape与Sun Microsystems建立了开发联盟，以及时完成LiveScript的发布。 在Netscape Navigator 2正式发布之前，Netscape将LiveScript的名称更改为JavaScript，以利用Java从新闻界收到的嗡嗡声。</p>
<p>由于JavaScript 1.0如此受欢迎，因此Netscape在Netscape Navigator 3中发布了1.1版。新兴Web的流行程度达到了新的高度，并且Netscape已将自己定位为市场上的领先公司。 此时，Microsoft决定将更多资源投入到一个名为Internet Explorer的竞争浏览器中。 在Netscape Navigator 3发布后不久，Microsoft引入了Internet Explorer 3，该Internet Explorer 3带有一个名为JScript的JavaScript实现（为了避免Netscape可能出现许可问题）。 对于Microsoft来说，1996年8月迈入Web浏览器领域的这一重要步骤对Netscape而言是一个臭名昭著的日子，但是它也代表着JavaScript作为一种语言的发展迈出了重要的一步。</p>
<p>微软对JavaScript的实现意味着有两种不同的JavaScript版本在浮动：Netscape Navigator中的JavaScript和Internet Explorer中的JScript。 与C和许多其他编程语言不同，JavaScript没有规范其语法或功能的标准，并且三个不同的版本仅突出了此问题。 随着业界的担忧加剧，决定必须将语言标准化。</p>
<p>1997年，JavaScript 1.1作为提案提交给了欧洲计算机制造商协会（Ecma）。 分配了第39技术委员会（TC39）以“标准化通用的，跨平台的，与供应商无关的脚本语言的语法和语义”（www.ecma-international.org/memento/TC39.htm）。 来自Netscape，Sun，Microsoft，Borland，NOMBAS和其他对脚本的未来感兴趣的公司的程序员，TC39召开了数月的会议，以敲定ECMA-262，该标准定义了一种名为ECMAScript的新脚本语言（通常发音为“ ek-ma-script”）。</p>
<p>次年，国际标准化组织和国际电工委员会（ISO / IEC）也采用ECMAScript作为标准（ISO / IEC-16262）。 从那时起，浏览器就以不同程度的成功尝试将ECMAScript用作其JavaScript实现的基础。</p>
<h3 id="javascript的实现">JAVASCRIPT的实现</h3>
<p>尽管经常将JavaScript和ECMAScript用作同义词，但JavaScript不仅限于ECMA-262中定义的内容。 实际上，一个完整的JavaScript实现由以下三个不同的部分组成（请参见图1-1）：</p>
<ul>
<li>核心（ECMAScript）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h3 id="ecmascript">ECMAScript</h3>
<p>ECMA-262中定义的语言ECMAScript与网络浏览器无关。 实际上，该语言没有任何输入或输出方法。  ECMA-262将该语言定义为可以构建更强大的脚本语言的基础。  Web浏览器只是其中可能存在ECMAScript实现的一种主机环境。 主机环境提供ECMAScript的基本实现以及旨在与环境本身交互的实现扩展。诸如文档对象模型（DOM）之类的扩展使用ECMAScript的核心类型和语法来提供特定于环境的附加功能。其他主机环境包括NodeJS，服务器端JavaScript平台和日益淘汰的Adobe Flash。</p>
<p>ECMA-262如果不引用网络浏览器，究竟会指定什么？ 在最基本的层次上，它描述了语言的以下部分：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>运算符</li>
<li>全局对象</li>
</ul>
<p>ECMAScript只是对语言的描述，该语言实现了规范中描述的所有方面。  JavaScript实现ECMAScript，Adobe ActionScript也实现。</p>
<h3 id="ecmascript版本">ECMAScript版本</h3>
<p>ECMAScript的不同版本定义为版本（指的是描述特定实现的ECMA-262版本）。ECMA-262的最新版本是2016年发布的第7版。ECMA-262的第一版与Netscape的JavaScript 1.1基本上相同，但是删除了对特定于浏览器的代码的所有引用，并做了一些小的更改：ECMA-262 需要支持Unicode标准（以支持多种语言），并且对象是平台无关的（Netscape JavaScript 1.1实际上具有不同的对象实现，例如Date对象，具体取决于平台）。 这是JavaScript 1.1和1.2不符合ECMA-262第一版的主要原因。</p>
<p>ECMA-262的第二版主要是社论。 该标准已更新，已与ISO / IEC-16262达成严格协议，并且没有任何添加，更改或遗漏。  ECMAScript实施通常不使用第二版来衡量一致性。</p>
<p>ECMA-262的第三版是对该标准的首次真正更新。 它提供了字符串处理，错误定义和数字输出的更新。 它还增加了对正则表达式，新的控制语句，try-catch异常处理和小的更改的支持，以更好地为国际化准备标准。 对许多人来说，这标志着ECMAScript作为一种真正的编程语言的到来。</p>
<p>ECMA-262的第四版是对该语言的全面修订。 为了响应JavaScript在Web上的普及，开发人员开始修订ECMAScript，以满足全球Web开发不断增长的需求。 作为响应，Ecma TC39再次召开会议，决定该语言的未来。 最终的规范基于第三版定义了几乎全新的语言。 第四版包括强类型变量，新语句和数据结构，真实类和经典继承以及与数据交互的新方法。</p>
<p>作为替代建议，TC39的一个小组委员会开发了一种名为“ ECMAScript 3.1”的规范，作为该语言的较小演变，该委员会认为第四版对于该语言而言实在太大了。 结果是提出了一个较小的建议，其中对ECMAScript进行了增量更改，可以在现有JavaScript引擎之上实施。 最终，ES3.1小组委员会赢得了TC39的支持，而ECMA-262的第四版在正式发布之前就被放弃了。</p>
<p>ECMAScript 3.1成为ECMA-262，第五版，并于2009年12月3日正式发布。第五版试图澄清第三版的模棱两可之处，并引入其他功能。 新功能包括一个用于解析和序列化JSON数据的本地JSON对象，用于继承和高级属性定义的方法，以及一个新的严格模式，该模式在某种程度上增强了ECMAScript引擎解释和执行代码的方式。 第五版于2011年6月进行了维护修订； 这仅是为了规范中的更正，没有引入任何新的语言或库功能。</p>
<p>ECMA-262的第六版（俗称<strong>ES6</strong>，ES2015或ES Harmony）已于2015年6月发布，可以说是自规范制定以来最重要的增强功能。 <strong>ES6添加了对类，模块，迭代器，生成器，箭头函数，promise，反射，代理和许多新数据类型的正式支持</strong>。</p>
<p>ECMA-262的第七版（称为ES7或ES2016）于2016年6月发布。此修订版仅包含少量语法添加，例如Array.prototype.includes和幂运算符。</p>
<p>ECMA-262的第八版（称为ES8或ES2017）已于2017年1月完成。此修订版包括异步迭代，休息和传播属性，新的正则表达式功能的集合，Promise finally（）catchall处理程序和模板文字 修订。</p>
<p>第九版ECMA-262仍在定稿中，但是在第3阶段它已经具有大量功能。它最重要的添加可能是动态导入ES6模块。</p>
<h3 id="文档对象模型">文档对象模型</h3>
<p>文档对象模型（DOM）是XML的应用程序编程接口（API），已扩展为在HTML中使用。  DOM将整个页面映射为节点层次结构。  HTML或XML页面的每个部分都是一种节点，其中包含不同种类的数据。 考虑以下HTML页面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-HTML" data-lang="HTML"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Sample Page<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span> Hello World!<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>可以使用DOM将这段代码绘制成节点的层次结构（请参见图1-2）。</p>
<p>通过创建代表文档的树，DOM使开发人员对其内容和结构的控制达到前所未有的水平。 可以使用DOM API轻松删除，添加，替换和修改节点。</p>
<h3 id="为什么需要dom">为什么需要DOM</h3>
<p>借助Internet Explorer 4和Netscape Navigator 4分别支持不同形式的动态HTML（DHTML），开发人员首次可以在不重新加载网页的情况下更改网页的外观和内容。 这代表了网络技术的巨大进步，但同时也是一个巨大的问题。  Netscape和Microsoft在开发DHTML时采取了不同的方式，从而结束了开发人员可以编写可由任何Web浏览器访问的单个HTML页面的时期。</p>
<p>决定必须采取一些措施来保留网络的跨平台性质。 担心的是，如果有人不控制Netscape和Microsoft，网络将发展为目标浏览器专有的两个不同的派系。 那时，负责创建Web通信标准的万维网联盟（W3C）开始研究DOM。</p>
<h3 id="dom级别">DOM级别</h3>
<p>DOM级别1在1998年10月成为W3C的推荐。它由两个模块组成：DOM核心，它提供了一种映射基于XML的文档的结构的方式，从而可以轻松地访问和操作文档的任何部分，  DOM HTML，通过添加特定于HTML的对象和方法扩展了DOM Core。</p>
<blockquote>
<p>注意:请注意，DOM不是特定于JavaScript的，并且确实已经以许多其他语言实现。 但是，对于Web浏览器，已经使用ECMAScript实现了DOM，现在DOM构成了JavaScript语言的很大一部分。</p>
</blockquote>
<p>DOM级别1的目标是映射文档的结构，而DOM级别2的目标则要广泛得多。 原始DOM的此扩展增加了对鼠标和用户界面事件（DHTML长期支持），范围和遍历（迭代DOM文档的方法）的支持，并通过对象界面支持<strong>层叠样式表（CSS）</strong>。 在级别1中引入的原始DOM Core也已扩展为包括对XML名称空间的支持。</p>
<h3 id="浏览器对象模型">浏览器对象模型</h3>
<p>Internet Explorer 3和Netscape Navigator 3浏览器具有浏览器对象模型（BOM），该模型允许访问和操纵浏览器窗​​口。 <strong>使用BOM，开发人员可以在其显示页面的上下文之外与浏览器进行交互</strong>。 使BOM表真正独特且常常存在问题的原因是，它是JavaScript实现中唯一没有相关标准的部分。 随着HTML5的引入，这种情况发生了变化，HTML5试图将许多BOM编入正式规范的一部分。 多亏了HTML5，有关BOM的许多困惑已消除。</p>
<p>首先，BOM处理浏览器的窗口和框架，但是通常任何特定于浏览器的JavaScript扩展都被视为BOM的一部分。 以下是一些此类扩展：</p>
<ul>
<li>弹出新浏览器窗口的功能</li>
<li>移动，调整和关闭浏览器窗口大小的功能</li>
<li>导航器对象，提供有关浏览器的详细信息</li>
<li>位置对象，提供有关浏览器中加载的页面的详细信息</li>
<li>屏幕对象，提供详细信息 有关用户屏幕分辨率的信息</li>
<li>性能对象，提供有关浏览器的内存消耗，导航行为和计时统计信息的详细信息</li>
<li>对cookie的支持</li>
<li>自定义对象（例如XMLHttpRequest和Internet Explorer的ActiveXObject）</li>
</ul>
<p>由于很长一段时间以来，BOM都没有标准，因此每个浏览器都有自己的实现。有一些事实上的标准，例如具有窗口对象和导航器对象，但是每个浏览器都为这些对象和其他对象定义了自己的属性和方法。 现在有了HTML5，BOM的实现细节有望以更加兼容的方式增长。在“浏览器对象模型”一章中包含有关BOM的详细讨论。</p>
<h3 id="javascript版本">JAVASCRIPT版本</h3>
<p>作为原始Netscape的后代，Mozilla是唯一延续原始JavaScript版本编号顺序的浏览器供应商。 当将Netscape源代码分解成一个开源项目（名为Mozilla Project）时，JavaScript的最新浏览器版本是1.3。  （如前所述，版本1.4仅在服务器上实现。）随着Mozilla Foundation继续从事JavaScript的工作，添加了新功能，关键字和语法，JavaScript版本号也随之增加。</p>
<p>编号方案基于Firefox 4将具有JavaScript 2.0的思想，并且在此之前版本号的每次增加都表示JavaScript实现与2.0提案有多接近。 尽管这是最初的计划，但是JavaScript的发展是不可能的。 当前没有针对JavaScript 2.0的目标实现，并且这种样式化的版本控制在Firefox 4版本之后就停止了。</p>
<blockquote>
<p>注意:必须注意，只有Netscape / Mozilla浏览器遵循此版本控制方案。 例如，Internet Explorer具有不同的JScript版本号。 这些JScript版本与上表中提到的JavaScript版本完全不对应。 此外，大多数浏览器都将JavaScript支持与ECMAScript遵从程度和DOM支持联系起来。</p>
</blockquote>
<h3 id="小结">小结</h3>
<p><strong>JavaScript是一种旨在与网页交互的脚本语言</strong>，由以下三个不同的部分组成：</p>
<ul>
<li>在ECMA-262中定义的ECMAScript，提供核心功能</li>
<li>文档对象模型（DOM），提供用于处理网页内容的方法和界面</li>
<li>浏览器对象模型（BOM），提供与浏览器进行交互的方法和界面</li>
</ul>
<p>在五个主要的Web浏览器（Internet Explorer，Firefox，Chrome，Safari和Opera）中，对JavaScript的三个部分的支持程度各不相同。 通常，在所有浏览器中对ECMAScript 5的支持都很好，并且对ECMAScript 6和7的支持正在增长。对DOM的支持各不相同，但是3级合规性越来越规范。 尽管假定存在一些共同点，但HTML5中编入的BOM可能因浏览器而异。</p>
<h2 id="2html中的javascript">2、HTML中的JavaScript</h2>
<p>将JavaScript引入网页后，网页上的主流语言即HTML立刻出现了问题。 作为有关JavaScript的原始工作的一部分，Netscape试图找出如何使JavaScript在HTML页面中共存，而又不破坏这些页面在其他浏览器中的呈现方式。 经过反复试验，错误和争议，最终做出了一些决定，并同意将通用脚本支持引入网络。 在网络的早期阶段所做的许多工作都幸存下来，并在HTML规范中正式化。</p>
<h3 id="ltscriptgt元素">&lt;Script&gt;元素</h3>
<p>将JavaScript插入HTML页面的主要方法是通过&lt;script&gt;元素。此元素是由Netscape创建的，并首先在Netscape Navigator 2中实现。后来被添加到正式的HTML规范中。&lt;script&gt;元素有六个<strong>属性</strong>：</p>
<ul>
<li>async-可选。表示脚本应立即开始下载，但不应阻止页面上的其他操作，例如下载资源或等待其他脚本加载。仅对外部脚本文件有效。</li>
<li>charset-可选。使用src属性指定的代码的字符集。很少使用此属性，因为大多数浏览器都不尊重它的价值。</li>
<li>crossorigin-可选。 为关联的请求配置CORS设置； 默认情况下，根本不使用CORS。crossorigin =“ anonymous”将配置文件请求不设置凭据标志。  crossorigin =“ use-credentials”将设置凭据标志，这意味着传出的请求将包含凭据</li>
<li>defer-可选。 表示可以安全地推迟执行脚本，直到完全解析并显示了文档内容为止。 仅对外部脚本有效。  Internet Explorer 7和更早版本也允许使用内联脚本。</li>
<li>integrity-可选。 通过对照提供的加密签名检查检索到的资源，允许验证子资源完整性（SRI）。 如果检索到的资源的签名与此属性指定的签名不匹配，则页面将错误并且脚本将不会执行。 这对于确保内容分发网络（CDN）不提供恶意有效负载非常有用。</li>
<li>language-已弃用。 最初指示代码块正在使用的脚本语言（例如“ JavaScript”，“ JavaScript1.2”或“ VBScript”）。 大多数浏览器都忽略此属性。 它不应该被使用。</li>
<li>src-可选。 表示包含要执行代码的外部文件。</li>
<li>type-可选。 替换language； 指示代码块使用的脚本语言的内容类型（也称为MIME类型）。 传统上，此值始终为“ text / javascript”，尽管“ text / javascript”和“ text / ecmascript”均已弃用。  JavaScript文件通常以“ application / x-javascript” MIME类型提供服务，即使在type属性中设置此名称也可能导致脚本被忽略。 在非Internet Explorer浏览器中可用的其他值是“ application / javascript”和“ application / ecmascript”。 如果值为模块，则将代码视为ES6模块，然后才有资格使用import和export关键字。</li>
</ul>
<p>使用&lt;script&gt;元素有两种方法：将JavaScript代码直接嵌入到页面中，或包含来自外部文件的JavaScript。</p>
<h3 id="小结-1">小结</h3>
<p>使用&lt;script&gt;元素将JavaScript插入HTML页面。 该元素可用于将JavaScript嵌入HTML页面，使其与标记的其余部分保持内联，或包括存在于外部文件中的JavaScript。 以下是要点：</p>
<ul>
<li>要包含外部JavaScript文件，必须将src属性设置为要包含的文件的URL，该URL可以是与包含页面位于同一服务器上的文件，也可以是位于完全不同的域中的一个文件。</li>
<li>所有&lt;script&gt;元素均按照它们在页面上出现的顺序进行解释。 只要不使用defer和async属性，必须完全解释&lt;script&gt;元素中包含的代码，然后才能开始下一个&lt;script&gt;元素中的代码。</li>
<li>对于非延迟脚本，浏览器必须先完成&lt;script&gt;元素内的代码解释，然后才能继续呈现页面的其余部分。 因此，通常在页面末尾，主要内容之后以及结束&lt;/body&gt;标记之前包含&lt;script&gt;元素。</li>
<li>您可以使用defer属性将脚本的执行推迟到文档渲染完成之后。 延迟脚本始终按照指定的顺序执行。</li>
<li>您可以使用async属性指示一个脚本无需等待其他脚本，也不必阻止文档呈现。 异步脚本不能保证以它们在页面中出现的顺序执行。</li>
</ul>
<p>通过使用&lt;noscript&gt;元素，您可以指定仅当浏览器不提供脚本支持时才显示内容。如果在浏览器中启用了脚本，则不会呈现&lt;noscript&gt;元素中包含的任何内容。</p>
<h2 id="3语言基础">3、语言基础</h2>
<h3 id="语法">语法</h3>
<p>ECMAScript的语法大量借鉴了C语言和其他类似C的语言，例如Java和Perl。熟悉此类语言的开发人员应该可以轻松地掌握ECMAScript较为宽松的语法。</p>
<h3 id="区分大小写">区分大小写</h3>
<p>要理解的第一个概念是，所有内容都区分大小写。 变量，函数名和运算符均区分大小写，这意味着名为test的变量与名为Test的变量不同。 同样，typeof不能是函数的名称，因为它是关键字（在下一节中介绍）； 但是，typeof是一个完全有效的函数名称。</p>
<h3 id="标识符">标识符</h3>
<p><strong>标识符</strong>是变量，函数，属性或函数参数的名称。标识符可以是一个或多个以下格式的字符：</p>
<ul>
<li>第一个字符必须是字母，下划线（_）或美元符号（$）。</li>
<li>所有其他字符可以是字母，下划线，美元符号或数字。</li>
</ul>
<p>标识符中的字母可以包括扩展的ASCII或Unicode字母字符，例如À和Æ，尽管不建议这样做。</p>
<p>按照惯例，ECMAScript标识符<strong>使用驼峰式大小写</strong>，这意味着<strong>第一个字母是小写字母，每个其他单词都用大写字母偏移</strong>，如下所示：</p>
<ul>
<li>firstSecond</li>
<li>myCar</li>
<li>doSomethingImportant</li>
</ul>
<p>尽管未严格执行此操作，但遵循遵循此格式的内置ECMAScript函数和对象被视为最佳实践。</p>
<blockquote>
<p>注意：关键字，保留字，true，false和null不能用作标识符。有关更多详细信息，请参见稍后出现的“关键字和保留字”部分。</p>
</blockquote>
<h3 id="注释">注释</h3>
<p>ECMAScript对单行注释和块注释均使用C样式注释。单行注释以两个正斜杠字符开头，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="c1">// single line comment
</span></code></pre></td></tr></table>
</div>
</div><p>块注释以正斜杠和星号（/ <em>）开头，以反斜杠（</em> /）结束，如以下示例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="cm">/* This is a multi-line
</span><span class="cm">comment */</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="严格模式">严格模式</h3>
<p>ECMAScript 5引入了严格模式的概念。 严格模式是JavaScript的另一种解析和执行模型，其中ECMAScript 3的某些不稳定行为已得到解决，并且为不安全的活动抛出了错误。 要为整个脚本启用严格模式，请在顶部包括以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="s2">&#34;use strict&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>尽管这看起来像是未分配给变量的字符串，但这是一种杂语，它告诉支持JavaScript的引擎更改为严格模式。语法是专门选择的，以免破坏ECMAScript 3语法。</p>
<p>您还可以通过在函数主体顶部包括编译指示来指定仅在严格模式下执行的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="s2">&#34;use strict&#34;</span><span class="p">;</span>
    <span class="c1">// function body
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>严格模式改变了JavaScript执行方式的许多部分，因此，整本书都指出了严格的模式区别。 所有现代浏览器均支持严格模式。</p>
<h3 id="陈述">陈述</h3>
<p>ECMAScript中的语句以分号终止，尽管省略分号会使解析器确定语句末尾的位置。</p>
<p>即使在语句末尾不需要分号，也应始终包括一个分号。包括分号有助于防止遗漏错误，例如不完成您键入的内容，并允许开发人员通过删除多余的空格来压缩ECMAScript代码（当行不以分号结尾时，这种压缩会导致语法错误）。 在某些情况下，包括分号也可以提高性能，因为解析器会尝试通过在它们似乎属于的地方插入分号来纠正语法错误。</p>
<p>可以使用C样式语法将多个语句组合到代码块中，以左花括号（{）开始，以右花括号（}）结尾：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="k">if</span> <span class="p">(</span><span class="nx">test</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">test</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>控制语句（例如if）仅在执行多个语句时才需要代码块。 但是，最好将代码块始终与控制语句一起使用，即使只有一条语句要执行.</p>
<p>将代码块用于控制语句可以使意图更清晰，并且在需要进行更改时出现错误的可能性较小。</p>
<h3 id="关键字和保留字">关键字和保留字</h3>
<p>ECMA-262描述了一组保留的关键字，它们具有特定的用途，例如指示控制语句的开始或结束或执行特定的操作。根据规则，关键字是保留的，不能用作标识符或属性名称。 第六版ECMA-262的<strong>关键字</strong>完整列表如下：</p>
<p>break do in typeof <br>
case else instanceof var  <br>
catch export new void  <br>
class extends return while  <br>
const finally super with<br>
continue for switch yield <br>
debugger function this <br>
default if throw <br>
delete import try</p>
<p>该规范还描述了一组将来的保留字，它们不能用作标识符或属性名。尽管保留字在语言中没有任何特定用法，但保留它们以备将来用作关键字。</p>
<p>以下是ECMA-262（第六版）中定义的将来保留字的完整列表：</p>
<ul>
<li>一律保留：enum</li>
<li>在严格模式下保留：implements package public interface protected static let private</li>
<li>在模块代码中保留：await</li>
</ul>
<p>这些词可能仍不能用作标识符，但现在可以用作对象中的属性名称。一般来说，最好避免同时使用关键字和保留字作为标识符和属性名称，以确保与过去和将来的ECMAScript版本兼容。</p>
<h3 id="变量">变量</h3>
<p>ECMAScript变量是<strong>松散类型</strong>的，这意味着<strong>变量可以保存任何类型的数据</strong>。 每个变量只是一个值的命名占位符。 可以使用三个关键字来声明变量：var（在所有ECMAScript版本中可用）以及const和let（在ECMAScript 6中引入）。</p>
<h3 id="var关键字">“var”关键字</h3>
<p>要定义变量，请使用var运算符（请注意var是关键字），后跟变量名称（如前所述，为标识符），如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">message</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码定义了一个名为message的变量，可以用来保存任何值。（不进行初始化，它将保留未定义的特殊值，这将在下一节中讨论。）ECMAScript实现变量初始化，因此可以定义变量并同时设置其值，如下例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在此，message定义为保留字符串值“ hi”。 进行初始化不会将变量标记为字符串类型； 它只是将值分配给变量。 仍然不仅可以更改存储在变量中的值，还可以更改值的类型，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span>
<span class="nx">message</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// legal, but not recommended
</span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，变量message首先被定义为具有字符串值“ hi”，然后被数字值100覆盖。尽管不建议切换变量包含的数据类型，但这在ECMAScript中是完全有效的。</p>
<h3 id="var声明范围">var声明范围</h3>
<p>重要的是要注意，使用var运算符定义变量可以使其在定义该函数的函数范围内是局部的。例如，<strong>使用var在函数内部定义变量意味着该函数退出后立即销毁该变量</strong>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span> <span class="c1">// local variable
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">test</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// error!
</span></code></pre></td></tr></table>
</div>
</div><p>在此，message变量是在使用var的函数中定义的。 该函数称为test（），该函数创建变量并分配其值。 之后，该变量立即被销毁，因此本示例中的最后一行会导致错误。 但是，可以通过如下简单地<strong>省略var运算符来全局定义变量</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span> <span class="c1">// global variable
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">test</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// &#34;hi&#34;
</span></code></pre></td></tr></table>
</div>
</div><p>通过从示例中删除var运算符，消息变量将变为全局变量。 一旦调用了test（）函数，该变量即被定义，并且一旦执行便可以在函数外部访问。</p>
<blockquote>
<p>注意:尽管可以通过省略var运算符来定义全局变量，但不建议使用此方法。 局部定义的全局变量难以维护，并且会引起混乱，因为是否有意省略var尚不明显。 当为未声明的变量分配值时，严格模式将引发ReferenceError。</p>
</blockquote>
<p>如果需要定义多个变量，则可以使用一个语句来完成，用逗号分隔每个变量（和可选的初始化），如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">,</span>
    <span class="nx">found</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">age</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在此，定义并初始化了三个变量。 由于ECMAScript是松散类型的，因此可以将使用不同数据类型的变量初始化组合为一个语句。 尽管没有必要插入换行符和使变量缩进，但这有助于提高可读性。</p>
<p><strong>在严格模式下运行时，不能定义名为eval或arguments的变量</strong>。这样做会导致语法错误。</p>
<h3 id="var声明提升">var声明提升</h3>
<p>使用var时，可能会发生以下情况，因为使用该关键字声明的变量被提升到函数作用域的顶部：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// undefined
</span></code></pre></td></tr></table>
</div>
</div><p>这不会引发错误，因为ECMAScript运行时在技术上将其视为这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">age</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
    <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// undefined
</span></code></pre></td></tr></table>
</div>
</div><p>这是“提升”，解释器将所有变量声明拉到其作用域的顶部。 它还允许您使用冗余的var声明而不会受到惩罚：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// 36
</span></code></pre></td></tr></table>
</div>
</div><h3 id="let声明">“let”声明</h3>
<p>let的操作几乎与var相同，但是有一些重要的区别。 最值得注意的是<strong>let是块作用域</strong>的，而<strong>var是函数作用域的</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Matt
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Matt
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 26
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// ReferenceError: age is not defined
</span></code></pre></td></tr></table>
</div>
</div><p>在这里，age变量不能在if块之外引用，因为它的范围不会扩展到该块之外。 块作用域严格来说是函数作用域的子集，因此任何适用于var声明的作用域限制也将适用于let声明。</p>
<p>let声明还不允许在块范围内进行任何多余的声明。这样做将导致错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">name</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">name</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">age</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">age</span><span class="p">;</span> <span class="c1">// SyntaxError; identifier &#39;age&#39; has already been declared
</span></code></pre></td></tr></table>
</div>
</div><p>当然，JavaScript引擎将跟踪用于变量声明的标识符及其在其中声明的块作用域，因此使用相同标识符的嵌套的行为与您期望的一样，没有错误，因为没有发生重新声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Nicholas&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#39;Nicholas&#39;
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#39;Matt&#39;
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 30
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 26
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>声明冗余错误不是顺序的函数，如果let与var混合，则不会受到影响。不同的关键字不会声明变量的不同类型，它们只是指定变量在相关范围内的存在方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">name</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">name</span><span class="p">;</span> <span class="c1">// SyntaxError
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">age</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">age</span><span class="p">;</span> <span class="c1">// SyntaxError
</span></code></pre></td></tr></table>
</div>
</div><h3 id="时间死区">时间死区</h3>
<p>let区别于var的另一个重要行为是，let声明不能以假定提升的方式使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="c1">// name is hoisted
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// undefined
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>

<span class="c1">// age is not hoisted
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// ReferenceError: age is not defined
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>解析代码时，JavaScript引擎仍会知道稍后在块中出现的let声明，但是在实际声明发生之前，将无法以任何方式引用这些变量。 在声明之前发生的执行段称为“时间死区”，任何对这些变量的引用尝试都将引发ReferenceError。</p>
<h3 id="全局声明">全局声明</h3>
<p>与var关键字不同，在全局上下文中使用let声明变量时，变量不会像使用var那样附加到窗口对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JS" data-lang="JS"><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#39;Matt&#39;
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// undefined
</span></code></pre></td></tr></table>
</div>
</div><p>但是，let声明仍将在全局块作用域内发生，该作用域将在页面的生存期内保持不变。 因此，必须确保页面不会尝试重复声明，以避免引发SyntaxError。</p>
<h3 id="有条件的声明">有条件的声明</h3>
<p>当使用var声明变量时，由于提升了声明，因此JavaScript引擎会很乐意将冗余声明合并到作用域顶部的单个声明中。由于let声明的作用域是块，因此无法检查是否曾经声明过let变量，只有在没有声明时才有条件地声明它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-HTML" data-lang="HTML"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Nicholas&#39;</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// Suppose this script is unsure about what has already been declared in the page.
</span><span class="c1"></span>    <span class="c1">// It will assume variables have not been declared.
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
    <span class="c1">// No problems here, since this will be handled as a single hoisted declaration.
</span><span class="c1"></span>    <span class="c1">// There is no need to check if it was previously declared.
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
    <span class="c1">// This will throw an error when &#39;age&#39; has already been declared.
</span><span class="c1"></span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 try/catch 语句或 typeof 运算符不是解决方案，因为条件块中的let声明将作用于该块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Nicholas&#39;</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// Suppose this script is unsure about what has already been declared in the page.
</span><span class="c1"></span>    <span class="c1">// It will assume variables have not been declared.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">name</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// &#39;name&#39; is restricted to the if {} block scope,
</span><span class="c1"></span>    <span class="c1">// so this assignment will act as a global assignment
</span><span class="c1"></span>    <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
    
    <span class="k">try</span> <span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If age is not declared, this will throw an error
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">age</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// &#39;age&#39; is restricted to the catch {} block scope,
</span><span class="c1"></span>    <span class="c1">// so this assignment will act as a global assignment
</span><span class="c1"></span>    <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>因此，您不能依靠带有此新ES6声明关键字的条件声明模式。</p>
<blockquote>
<p>注意: 不能使用let进行条件声明是一件好事，因为条件声明是代码库中的错误模式。 这使得很难理解程序流程。 如果您发现自己已经达到了这种模式，那么很有可能找到一种更好的方式编写它。</p>
</blockquote>
<h3 id="循环中的let声明">循环中的let声明</h3>
<p>在let出现之前，for循环定义涉及使用迭代器变量，该变量的定义会在循环主体之外流出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do loop things
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 5
</span></code></pre></td></tr></table>
</div>
</div><p>切换到let声明时，这不再是问题，因为iterator变量将仅作用于for循环块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do loop things
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// ReferenceError: i is not defined
</span></code></pre></td></tr></table>
</div>
</div><p>使用var时，经常遇到的问题是迭代器变量的单数声明和修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// You might expect this to console.log 0, 1, 2, 3, 4
</span><span class="c1">// It will actually console.log 5, 5, 5, 5, 5
</span></code></pre></td></tr></table>
</div>
</div><p>发生这种情况是因为循环退出时，其迭代器变量仍设置为导致循环退出的值：5。稍后执行超时时，它们引用该变量，因此console.log其最终值。</p>
<p>使用let声明循环迭代器时，JavaScript引擎实际上会在每次循环迭代时声明一个新的迭代器变量。 每个setTimeout都引用该单独的实例，因此它将console.log期望的值：执行该循环迭代时迭代器变量的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// console.logs 0, 1, 2, 3, 4
</span></code></pre></td></tr></table>
</div>
</div><p>这种逐项声明的行为适用于所有样式的for循环，包括for-in和for-of循环。</p>
<h3 id="const声明">“const”声明</h3>
<p>const的行为与let的行为相同，但有一个重要的区别-必须使用一个值对其进行初始化，并且在声明后不能重新定义该值。 尝试修改const变量将导致运行时错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
<span class="nx">age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span> <span class="c1">// TypeError: assignment to a constant
</span><span class="c1"></span>
<span class="c1">// const still disallows redundant declaration
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Nicholas&#39;</span><span class="p">;</span> <span class="c1">// SyntaxError
</span><span class="c1">// const is still scoped to blocks
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Nicholas&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Matt
</span></code></pre></td></tr></table>
</div>
</div><p>const声明仅相对于对其所指向的变量的引用而强制执行。如果const变量引用了一个对象，则它不会违反const约束来修改该对象内部的属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Matt&#39;</span><span class="p">;</span> <span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>即使JavaScript引擎正在for循环中创建let迭代器变量的新实例，并且即使const变量的行为与let变量相似，也不能使用const声明for循环迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// TypeError: assignment to constant variable
</span></code></pre></td></tr></table>
</div>
</div><p>但是，如果要声明未修改的for循环变量，则允许使用const，这恰好是因为每次迭代都声明了一个新变量。 这对于for-of和for-in循环尤为重要：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 7, 7, 7, 7, 7
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">})</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// a, b
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 1, 2, 3, 4, 5
</span></code></pre></td></tr></table>
</div>
</div><h3 id="声明样式和最佳做法">声明样式和最佳做法</h3>
<p>ECMAScript 6中let和const的引入以提高声明范围和语义精度的形式在客观上为该语言带来了更好的工具。 众所周知，var声明的异常行为导致JavaScript社区由于其引起的所有问题而拖延了多年的发展。 在引入这些新关键字之后，出现了一些可以提高代码质量的越来越常见的模式。</p>
<h4 id="不要使用var">不要使用var</h4>
<p>使用let和const，大多数开发人员将发现他们不再需要在任何地方的代码库中使用var。由于对变量范围，声明局部性和const正确性的精心管理，将变量声明限制为仅让let和const出现的模式将有助于提高代码库质量。</p>
<h4 id="喜欢const超过let">喜欢const超过let</h4>
<p>使用const声明允许浏览器运行时强制执行常量变量，以及使用静态代码分析工具来预见非法的重新分配操作。因此，许多开发人员认为默认情况下将变量声明为const对他们有利，除非他们知道他们需要在某个时候重新分配其值。这使开发人员可以更具体地推断出他们知道永远不会改变的值，并在代码执行尝试执行意外的值重新分配的情况下快速检测意外行为。</p>
<h3 id="数据类型">数据类型</h3>
<p>ECMAScript中有<strong>六种简单的数据类型（也称为原始类型）：Undefined，Null，Boolean，Number，String和Symbol</strong>。  Symbol是ECMAScript 6中新引入的。还有一个称为<strong>Object</strong>的复杂数据类型，它是名称-值对的无序列表。 由于无法在ECMAScript中定义自己的数据类型，因此<strong>所有值都可以表示为这七个值之一</strong>。 仅具有七个数据类型似乎太少而无法完全表示数据。 但是，ECMAScript的数据类型具有动态方面，使单个数据类型的行为都像多个数据类型。</p>
<h4 id="typeof运算符">typeof运算符</h4>
<p>由于ECMAScript是松散类型的，因此需要一种方法来确定给定变量的数据类型。  typeof运算符提供该信息。 在值上使用typeof运算符将返回以下字符串之一：</p>
<ul>
<li>如果值未定义，则为“undefined”</li>
<li>“boolean”（如果值是布尔值）</li>
<li>“string”（如果值是字符串）</li>
<li>“number”（如果值是数字）</li>
<li>“object”（如果值是对象（函数以外）或 null）</li>
<li>“function”（如果值是函数）</li>
<li>“symbol”（如果值是Symbol）</li>
</ul>
<p>typeof运算符的调用方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;some string&#34;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">message</span><span class="p">);</span> <span class="c1">// &#34;string&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span> <span class="c1">// &#34;string&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="mi">95</span><span class="p">);</span> <span class="c1">// &#34;number&#34;
</span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，变量（message）和数字文字均传递到typeof运算符中。请注意，由于<strong>typeof是运算符而不是函数，因此不需要括号（尽管可以使用它们）</strong>。</p>
<p>请注意，在某些情况下typeof似乎返回了一个令人困惑但在技术上正确的值。 调用typeof null返回值“ object”，因为特殊值null被认为是空对象引用。</p>
<blockquote>
<p>注意: 从技术上讲，函数在ECMAScript中被视为对象，并不代表其他数据类型。 但是，它们确实具有一些特殊的属性，这需要通过typeof运算符区分函数和其他对象。</p>
</blockquote>
<h4 id="undefined类型">Undefined类型</h4>
<p>未定义类型只有一个值，即特殊值undefined。 使用var或let声明变量但未初始化变量时，将为其分配undefined值，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，声明变量message时不对其进行初始化。 与undefined的文字值比较时，两者相等。 此示例与以下示例相同：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>此处，变量message已显式初始化为undefined。这是不必要的，因为默认情况下，任何未初始化的变量都将获得undefined的值。</p>
<blockquote>
<p>注意: 通常来说，您绝对不应将变量明确设置为undefined。 字面量undefined值主要用于比较，直到第三版ECMA-262才添加，以帮助形式化空对象指针（null）和未初始化变量之间的差异。</p>
</blockquote>
<p>请注意，包含undefined值的变量与根本没有定义的变量不同。 考虑以下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span><span class="p">;</span> <span class="c1">// this variable is declared but has a value of undefined
</span><span class="c1">// make sure this variable isn&#39;t declared
</span><span class="c1">// let age
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// &#34;undefined&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// causes an error
</span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，第一个console.log显示变量消息，该消息为“undefined”。 在第二个console.log中，未声明的变量age被传递到console.log（）函数中，这会导致错误，因为尚未声明该变量。 未声明的变量只能执行一个有用的操作：您可以在其上调用typeof（在未声明的变量上调用delete不会导致错误，但这不是很有用，实际上在严格模式下会引发错误）。</p>
<p>当对未初始化的变量进行调用时，typeof运算符将返回“ undefined”，但对未声明的变量进行调用时，也会返回“ undefined”，这可能会造成混淆。 考虑以下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span><span class="p">;</span> <span class="c1">// this variable is declared but has a value of undefined
</span><span class="c1">// make sure this variable isn&#39;t declared
</span><span class="c1">// let age
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">message</span><span class="p">);</span> <span class="c1">// &#34;undefined&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">age</span><span class="p">);</span> <span class="c1">// &#34;undefined&#34;
</span></code></pre></td></tr></table>
</div>
</div><p>在这两种情况下，在变量上调用typeof都会返回字符串“ undefined”。 从逻辑上讲，这是有道理的，因为即使在技术上存在很大差异，也无法使用任何一个变量执行实际操作。</p>
<blockquote>
<p>注意: 即使未初始化的变量会自动分配为undefined的值，<strong>建议始终初始化变量</strong>。 这样，当typeof返回“undefined”时，您会知道这不是因为尚未声明给定变量，而只是未对其进行初始化。</p>
</blockquote>
<p>undefined的值是false的；因此，您可以在需要的地方进行更简洁的检查。但是请记住，许多其他可能的值也是虚假的，因此在需要测试确切值undefined而不是虚假值的情况下要小心：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span><span class="p">;</span> <span class="c1">// this variable is declared but has a value of undefined
</span><span class="c1">// &#39;age&#39; is not declared
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will not execute
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will execute
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This will throw an error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="null类型">Null类型</h4>
<p>Null类型是仅具有一个值的第二种数据类型：特殊值null。 从逻辑上讲，空值是一个空的对象指针，这就是为什么在以下示例中typeof传递空值时会返回“对象”的原因：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">car</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">car</span><span class="p">);</span> <span class="c1">// &#34;object&#34;
</span></code></pre></td></tr></table>
</div>
</div><p><strong>当定义一个打算稍后用于保存对象的变量时，建议将变量初始化为null</strong>，而不是其他任何东西。 这样，您可以显式检查值null，以确定该变量以后是否已用对象引用填充，例如以下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="nx">car</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something with car
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>值undefined是null的派生，因此ECMA-262将它们定义为表面上相等，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>在空值和未定义值之间使用相等运算符（==）始终返回true，但请记住，==运算符将转换其操作数以进行比较（本章稍后将详细介绍）。</p>
<p>即使null和undefined相关联，它们的用法也有很大不同。 如前所述，永远不要将变量的值显式设置为undefined，但对于null则不适用。 任何时候期望对象但不可用，都应在其位置使用null。 这有助于将null范式保留为空对象指针，并进一步将其与undefined区分开。</p>
<p>空类型是false的。 因此，您可以在需要的地方进行更简洁的检查。 但是请记住，许多其他可能的值也是false的，因此在需要测试确切的null值而不是false的值的情况下要小心：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">age</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will not execute
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will execute
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will not execute
</span><span class="c1"></span><span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This block will execute
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="boolean类型">Boolean类型</h4>
<p>布尔类型是ECMAScript中最常用的类型之一，只有两个文字值：true和false。 这些值与数值不同，因此<strong>true不等于1</strong>，<strong>false不等于0</strong>。将布尔值分配给变量如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">found</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">lost</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，布尔文字true和false区分大小写，因此True和False（以及其他大写和小写字母的混合形式）作为标识符有效，但对于布尔值无效。</p>
<p>尽管只有两个文字布尔值，但是所有类型的值在ECMAScript中都具有等效的布尔值。 要将值转换为其等效的布尔值，将调用特殊的Boolean（）强制转换函数，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;Hello world!&#34;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">messageAsBoolean</span> <span class="o">=</span> <span class="nb">Boolean</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在此示例中，字符串message被转换为布尔值并存储在messageAsBoolean中。可以在任何类型的数据上调用Boolean（）强制转换函数，并且始终返回布尔值。何时将值转换为true或false的规则取决于数据类型以及实际值。下表概述了各种数据类型及其特定的转换:</p>
<p>理解这些转换很重要，因为流控制语句（例如if语句）会自动执行此布尔转换，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;Hello world!&#34;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Value is true&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在此示例中，将显示console.log，因为字符串消息将自动转换为其等效的布尔值（true）。 重要的是要了解由于这种自动转换而在流控制语句中使用的变量。 错误地使用对象而不是布尔值可以极大地改变应用程序的流程。</p>
<h4 id="number类型">Number类型</h4>
<p>ECMAScript中最有趣的数据类型可能是数字，它使用IEEE–754格式表示整数和浮点值（在某些语言中也称为双精度值）。 为了支持各种类型的数字，有几种不同的数字文字格式。</p>
<p>最基本的数字文字格式是十进制整数格式，可以直接输入。</p>
<p>整数也可以表示为八进制（基数8）或十六进制（基数16）文字。 对于八进制文字，第一个数字必须为零（0），后跟八进制数字序列（数字0至7）。如果在文字中检测到超出此范围的数字，那么将忽略前导零，并将该数字视为十进制，如以下示例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">octalNum1</span> <span class="o">=</span> <span class="mi">070</span><span class="p">;</span> <span class="c1">// octal for 56
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">octalNum2</span> <span class="o">=</span> <span class="mi">079</span><span class="p">;</span> <span class="c1">// invalid octal - interpreted as 79
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">octalNum3</span> <span class="o">=</span> <span class="mi">08</span><span class="p">;</span> <span class="c1">// invalid octal - interpreted as 8
</span></code></pre></td></tr></table>
</div>
</div><p>在严格模式下运行时，八进制文字无效，并且会导致JavaScript引擎引发语法错误。</p>
<p>要创建十六进制文字，您必须使前两个字符为0x（不区分大小写），后接任意数量的十六进制数字（0至9，以及A至F）。 字母可以大写或小写。 这是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">hexNum1</span> <span class="o">=</span> <span class="mh">0xA</span><span class="p">;</span> <span class="c1">// hexadecimal for 10
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">hexNum2</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span> <span class="c1">// hexadecimal for 31
</span></code></pre></td></tr></table>
</div>
</div><p>使用八进制或十六进制格式创建的数字在所有算术运算中均视为十进制数字。</p>
<blockquote>
<p>注意: 由于数字在JavaScript中的存储方式，实际上可能有一个正零（+0）和负零（–0）值。 在所有情况下，正零和负零被认为是等效的，但为清楚起见，在本文中对其进行了注明。</p>
</blockquote>
<p>要定义浮点值，必须包含一个小数点，并且在小数点后至少要有一个数字。 尽管小数点前不需要整数，但建议使用。 这里有些例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">floatNum1</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">floatNum2</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">floatNum3</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">;</span> <span class="c1">// valid, but not recommended
</span></code></pre></td></tr></table>
</div>
</div><p>因为存储浮点值使用的内存是存储整数值的两倍，所以ECMAScript始终在寻找将值转换为整数的方法。如果小数点后没有数字，则该数字变为整数。 同样，如果要表示的数字是整数（例如1.0），则它将转换为整数，如本例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">floatNum1</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// missing digit after decimal - interpreted as integer 1
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">floatNum2</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span> <span class="c1">// whole number - interpreted as integer 10
</span></code></pre></td></tr></table>
</div>
</div><p>对于非常大或非常小的数字，可以使用e表示法表示浮点值。E表示用来表示一个数字，该数字应乘以10等于给定幂。  ECMAScript中的电子注释格式为数字（整数或浮点数），后跟大写或小写字母E，再乘以10的幂。 考虑以下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">floatNum</span> <span class="o">=</span> <span class="mf">3.125e7</span><span class="p">;</span> <span class="c1">// equal to 31250000
</span></code></pre></td></tr></table>
</div>
</div><p>在此示例中，即使floatNum使用e表示法以更紧凑的形式表示，也等于31,250,000。 该符号本质上说：“取3.125乘以10^7。”</p>
<p>e符号也可以用于表示非常小的数字，例如0.00000000000000003，可以将其更简洁地写为3e-17。 默认情况下，ECMAScript会将小数点后至少六个零的任何浮点值转换为e表示法（例如，0.0000003变为3e–7）。</p>
<p>浮点值的精度最高为小数点后17位，但算术计算中的精度远不如整数。 例如，将0.1和0.2相加将产生0.30000000000000004而不是0.3。 这些小的舍入误差使得很难测试特定的浮点值。考虑以下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">==</span> <span class="mf">0.3</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// avoid!
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;You got 0.3.&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，测试了两个数字的总和，看是否等于0.3。 这将适用于0.05和0.25以及0.15和0.15。 但是，如前所述，如果应用于0.1和0.2，则此测试将失败。因此，永远不要测试特定的浮点值。</p>
<blockquote>
<p>注意: 必须了解，舍入误差是浮点算术在基于IEEE-754的数字中完成的方式的副作用，并且并非ECMAScript独有。使用相同格式的其他语言也存在相同的问题。</p>
</blockquote>
<h5 id="取值范围">取值范围</h5>
<p>由于内存限制，并非世界上所有数字都可以用ECMAScript表示。ECMAScript中可以表示的最小数字存储在<strong>Number.MIN_VALUE</strong>中，并且在大多数浏览器中为5e–324。 最大的数字存储在<strong>Number.MAX_VALUE</strong>中，并且在大多数浏览器中为1.7976931348623157e + 308。 如果计算得出的数字无法用JavaScript的数字范围表示，则该数字会自动获得Infinity的特殊值。 任何不能表示的负数是–Infinity（负无穷大），任何不能表示的正数就是Infinity（正无穷大）</p>
<p>如果计算返回正或负的Infinity，则该值不能再用于任何进一步的计算，因为Infinity没有用于计算的数字表示形式。 为了确定一个值是否是有限的（即它出现在最小值和最大值之间），有一个<strong>isFinite（）函数</strong>。 仅当参数在最小值和最大值之间时，此函数才返回true，如以下示例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span> <span class="o">+</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span> <span class="c1">// false
</span></code></pre></td></tr></table>
</div>
</div><p>尽管很少会进行超出有限数值范围之外的值的计算，但是在进行非常大或非常小的计算时，这是可能的并且应受到监视。</p>
<blockquote>
<p>注意: 您还可以通过访问<strong>Number.NEGATIVE_INFINITY</strong>和<strong>Number.POSITIVE_INFINITY</strong>获取正负无穷大的值。 如您所料，这些属性分别包含值–Infinity和Infinity。</p>
</blockquote>
<h5 id="nan">NaN</h5>
<p>有一个特殊的数值，称为NaN，是Not Number的缩写，用于指示用于返回数字的操作何时失败（与引发错误相反）。 例如，将任何数字除以0通常会导致其他编程语言出错，从而导致代码执行中断。 在ECMAScript中，将<strong>数字除以0将返回NaN</strong>，这将允许其他处理继续进行。</p>
<p>NaN值具有几个独特的属性。 首先，任何涉及NaN的操作都始终返回NaN（例如NaN / 10），这在多步计算的情况下可能会出现问题。 其次，<strong>NaN不等于任何值，包括NaN</strong>。 例如，以下返回false：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">NaN</span> <span class="o">==</span> <span class="kc">NaN</span><span class="p">);</span> <span class="c1">// false
</span></code></pre></td></tr></table>
</div>
</div><p>因此，ECMAScript提供了isNaN（）函数。 该函数接受单个参数，该参数可以是任何数据类型，以确定该值是否为“非数字”。 将值传递给isNaN（）时，会尝试将其转换为数字。 一些非数字值会直接转换为数字，例如字符串“10”或布尔值。 任何不能转换为数字的值都会导致该函数返回true。考虑以下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">NaN</span><span class="p">));</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="c1">// false - 10 is a number
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="s2">&#34;10&#34;</span><span class="p">));</span> <span class="c1">// false - can be converted to number 10
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="s2">&#34;blue&#34;</span><span class="p">));</span> <span class="c1">// true - cannot be converted to a number
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span> <span class="c1">// false - can be converted to number 1
</span></code></pre></td></tr></table>
</div>
</div><h5 id="数值转换">数值转换</h5>
<p>可以使用三个函数将非数值转换为数字：Number（）强制转换函数，parseInt（）函数和parseFloat（）函数。 <strong>第一个函数Number（）可以用于任何数据类型</strong>。 <strong>另外两个函数专门用于将字符串转换为数字</strong>。这些功能对同一输入的反应不同。</p>
<h4 id="string类型">String类型</h4>
<p>String数据类型表示零个或多个16位Unicode字符的序列。 可以使用双引号（“），单引号（'）或反引号（`）来描述字符串。</p>
<h4 id="symbol类型">Symbol类型</h4>
<p>ECMAScript 6中的新增功能是Symbol数据类型。符号是原始值，符号实例是唯一且不可变的。符号的目的是成为对象属性的有保证的唯一标识符，而不会冒属性冲突的危险。</p>
<p>尽管它们似乎与私有属性具有某些相似之处，但是符号并不旨在提供私有属性行为（尤其是因为对象API提供了容易发现符号属性的方法）。 取而代之的是，符号旨在用作唯一的令牌，可用于使用字符串以外的其他键来键入特殊属性。</p>
<p>使用Symbol函数实例化符号。因为它是它自己的原始类型，所以typeof运算符会将一个符号标识为symbol。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">sym</span><span class="p">);</span> <span class="c1">// symbol
</span></code></pre></td></tr></table>
</div>
</div><p>调用该函数时，可以提供一个可选字符串，该字符串可用于在调试时标识符号实例。 您提供的字符串与符号的定义或标识完全分开：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">genericSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">otherGenericSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>

<span class="kd">let</span> <span class="nx">fooSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">otherFooSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">genericSymbol</span> <span class="o">==</span> <span class="nx">otherGenericSymbol</span><span class="p">);</span> <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fooSymbol</span> <span class="o">==</span> <span class="nx">otherFooSymbol</span><span class="p">);</span> <span class="c1">// false
</span></code></pre></td></tr></table>
</div>
</div><p>符号没有文字字符串语法，这对于它们的用途至关重要。 规范符号操作方式的规范允许您创建一个新的Symbol实例，并使用它在对象上键入新的属性，并确保您不会覆盖现有的对象属性-不管它是使用字符串还是使用Symbol作为对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">genericSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">genericSymbol</span><span class="p">);</span> <span class="c1">// Symbol()
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">fooSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fooSymbol</span><span class="p">);</span> <span class="c1">// Symbol(foo);
</span></code></pre></td></tr></table>
</div>
</div><p>重要的是，Symbol函数不能与new关键字一起使用。 这样做的目的是避免符号对象包装器，如Boolean，String和Number可能的那样，它们支持构造函数的行为并实例化原始包装器对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">myBoolean</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">myBoolean</span><span class="p">);</span> <span class="c1">// &#34;object&#34;
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">myString</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">myString</span><span class="p">);</span> <span class="c1">// &#34;object&#34;
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">myNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">myNumber</span><span class="p">);</span> <span class="c1">// &#34;object&#34;
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Symbol</span><span class="p">();</span> <span class="c1">// TypeError: Symbol is not a constructor
</span></code></pre></td></tr></table>
</div>
</div><p>如果您想使用对象包装器，可以使用Object（）函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">myWrappedSymbol</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">mySymbol</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">myWrappedSymbol</span><span class="p">);</span> <span class="c1">// &#34;object&#34;
</span></code></pre></td></tr></table>
</div>
</div><h3 id="小结-2">小结</h3>
<p>JavaScript的核心语言功能在ECMA-262中定义为名为ECMAScript的伪语言。  ECMAScript包含完成基本计算任务所需的所有基本语法，运算符，数据类型和对象，尽管它没有提供获取输入或产生输出的方法。了解ECMAScript及其复杂性对于全面了解Web浏览器中实现的JavaScript至关重要。 以下是ECMAScript的一些基本元素：</p>
<ul>
<li>ECMAScript中的基本数据类型为Undefined，Null，Boolean，Number，String和Symbol。</li>
<li>与其他语言不同，整数和浮点值没有单独的数据类型；Number类型代表所有数字。</li>
<li>还有一个复杂的数据类型Object，这是该语言中所有对象的基本类型。</li>
<li>严格模式限制了语言中某些容易出错的部分。</li>
<li>ECMAScript提供了许多C和其他类似C的语言可用的基本运算符，包括算术运算符，布尔运算符，关系运算符，相等运算符和赋值运算符。</li>
<li>这些语言的功能是流控制语句从其他语言中大量借用，例如if语句，for语句和switch语句。</li>
</ul>
<p>ECMAScript中的函数与其他语言中的函数有所不同：</p>
<ul>
<li>无需指定函数的返回值，因为任何函数都可以随时返回任何值。</li>
<li>未指定返回值的函数实际上会返回特殊值undefined。</li>
</ul>
<h2 id="4变量范围和内存">4、变量，范围和内存</h2>
<h3 id="小结-3">小结</h3>
<p>可以在JavaScript变量中存储两种类型的值：基本值和引用值。基本值具有六种基本数据类型之一：Undefined，Null，Boolean，Number，String和Symbol。基本值和引用值具有以下特征：</p>
<ul>
<li>基本值具有固定内存大小，因此存储在栈的内存中。</li>
<li>将基本值从一个变量复制到另一个变量将创建该值的第二个副本。</li>
<li>引用值是对象，并存储在堆的内存中。</li>
<li>包含引用值的变量实际上仅包含指向对象的指针，而不包含对象本身。</li>
<li>将引用值复制到另一个变量仅复制指针，因此两个变量最终都引用同一对象。</li>
<li>typeof运算符确定值的原始类型，而instanceof运算符用于确定值的引用类型。</li>
</ul>
<p>所有变量（基本变量和引用变量）都存在于执行上下文（也称为作用域）中，该上下文确定变量的生存期以及代码的哪些部分可以访问它。执行上下文可以总结如下：</p>
<ul>
<li>执行上下文全局存在（称为全局上下文），在函数内部以及在块内部。</li>
<li>每次输入新的执行上下文时，它都会创建一个范围链以搜索变量和函数。</li>
<li>函数或块局部的上下文不仅可以访问该范围内的变量，还可以访问任何包含其的上下文和全局上下文的变量。</li>
<li>全局上下文只能访问全局上下文中的变量和函数，而不能直接访问局部上下文中的任何数据。</li>
<li>变量的执行上下文有助于确定何时释放内存</li>
</ul>
<p>JavaScript是垃圾回收的编程环境，开发人员无需担心内存分配或回收问题。 JavaScript的垃圾回收例程可以总结如下：</p>
<ul>
<li>超出上下文的值将自动标记为回收，并在垃圾回收过程中将其删除。</li>
<li>主要的垃圾收集算法称为“标记清除”算法，该算法会标记当前未使用的值，然后返回以回收该内存。</li>
<li>另一种算法是引用计数，该算法跟踪特定值有多少个引用。JavaScript引擎不再使用此算法，但是由于在JavaScript中访问了非本地JavaScript对象（例如DOM元素），它仍然会影响Internet Explorer。</li>
<li>当代码中存在循环引用时，引用计数会导致问题。</li>
<li>取消引用变量不仅有助于循环引用，而且通常还有助于垃圾回收。 为了帮助进行内存回收，在不再需要全局对象，全局对象的属性和循环引用时，都应取消引用。</li>
</ul>
<h2 id="5基本引用类型">5、基本引用类型</h2>
<h3 id="小结-4">小结</h3>
<p>JavaScript中的对象称为引用值，可以使用几种内置引用类型来创建特定类型的对象，如下所示：</p>
<ul>
<li>引用类型类似于传统的面向对象编程中的类，但实现方式有所不同。</li>
<li>Date类型提供有关日期和时间的信息，包括当前日期和时间以及计算。</li>
<li>RegExp类型是ECMAScript中支持正则表达式的接口，提供最基本和一些高级的正则表达式功能。</li>
</ul>
<p>JavaScript的独特方面之一是，函数实际上是Function类型的实例，意味着函数是对象。 因为函数是对象，所以函数具有可用于增强其行为方式的方法。</p>
<p>由于存在原始包装类型，因此可以像对待对象一样访问JavaScript中的原始值。 共有三种原始包装器类型：布尔值，数字和字符串。 它们都具有以下特征：</p>
<ul>
<li>每个包装器类型都映射到相同名称的原始类型。</li>
<li>在读取模式下访问原始值时，将实例化原始包装器对象，以便可以将其用于处理数据。</li>
<li>一旦执行包含原始值的语句，包装对象就会被销毁。</li>
</ul>
<p>在代码执行开始时还存在两个内置对象：Global和Math。在大多数ECMAScript实施中无法访问Global对象； 但是，Web浏览器将其实现为窗口对象。全局对象包含所有全局变量和函数作为属性。 Math对象包含有助于复杂数学计算的属性和方法。</p>
<h2 id="6集合引用类型">6、集合引用类型</h2>
<h3 id="小结-5">小结</h3>
<p>JavaScript中的对象称为引用值，可以使用几种内置引用类型来创建特定类型的对象，如下所示：</p>
<ul>
<li>引用类型类似于传统的面向对象编程中的类，但实现方式有所不同。</li>
<li>对象类型是所有其他引用类型继承基本行为的基础。</li>
<li>Array类型表示值的有序列表，并提供用于操纵和转换值的功能。</li>
<li>类型化数组包含一系列不同的引用类型，这些引用类型涉及内存中数字的类型管理。</li>
<li>Date类型提供有关日期和时间的信息，包括当前日期和时间以及计算。</li>
<li>RegExp类型是ECMAScript中支持正则表达式的接口，提供最基本和一些高级的正则表达式功能。</li>
</ul>
<p>JavaScript的独特方面之一是，函数实际上是Function类型的实例，意味着函数是对象。 因为函数是对象，所以函数具有可用于增强其行为方式的方法。</p>
<p>由于存在原始包装类型，因此可以像对待对象一样访问JavaScript中的原始值。 共有三种原始包装器类型：布尔值，数字和字符串。 它们都具有以下特征：</p>
<ul>
<li>每个包装器类型都映射到相同名称的原始类型。</li>
<li>在读取模式下访问原始值时，将实例化原始包装器对象，以便可以将其用于处理数据。</li>
<li>一旦执行包含原始值的语句，包装对象就会被销毁。</li>
</ul>
<p>在代码执行开始时还存在两个内置对象：Global和Math。在大多数ECMAScript实施中无法访问Global对象； 但是，Web浏览器将其实现为窗口对象。 全局对象包含所有全局变量和函数作为属性。  Math对象包含有助于复杂数学计算的属性和方法。</p>
<p>ECMAScript 6引入了一些集合类型：Map，WeakMap，Set和WeakSet。 这些为组织应用程序数据以及简化内存管理提供了新的可能性。</p>
<h2 id="7迭代器和生成器">7、迭代器和生成器</h2>
<h3 id="小结-6">小结</h3>
<p>迭代实际上是每种编程语言都遇到的一种模式。ECMAScript 6规范通过在语言中引入两个正式的概念（迭代器和生成器）来正式包含迭代的概念。</p>
<p>迭代器是可以由任何对象实现的接口，并允许连续访问其生成的值。任何实现Iterable接口的功能都具有符号。iterator属性，它引用默认的迭代器。 默认的迭代器的行为就像一个迭代器工厂：一个函数，该函数在被调用时会产生一个实现Iterator接口的对象。</p>
<p>迭代器通过next（）方法强制继承值，该方法返回IteratorObject。 该对象包含一个done属性，一个布尔值（指示是否有更多可用值）以及一个value属性，其中包含从迭代器提供的当前值。该接口可以通过重复调用next（）来手动使用，也可以由本机可迭代使用方（例如for &hellip; of循环）自动使用。</p>
<p>生成器是一种特殊的函数，在调用时会生成生成器对象。该生成器对象实现了Iterable接口，因此可以在需要可迭代的任何地方使用。生成器的独特之处在于它们支持yield关键字，该关键字用于暂停生成器功能的执行。 yield关键字还可用于通过next（）方法接受输入和输出。当带有星号时，yield关键字将用于序列化与之配对的可迭代对象。</p>
<h2 id="8对象类和面向对象的编程">8、对象，类和面向对象的编程</h2>
<h3 id="小结-7">小结</h3>
<p>在代码执行期间的任何时候都可以创建和扩充对象，从而使对象成为动态的而非严格定义的实体。以下模式用于创建对象：</p>
<ul>
<li>工厂模式使用一个简单的函数创建一个对象，分配属性和方法，然后返回该对象。 当构造器模式出现时，该模式就不再受欢迎。</li>
<li>使用构造器模式，可以定义可以使用new运算符创建自定义引用类型的方式，就像创建内置对象实例一样。但是，构造器模式确实有一个缺点，即它的成员（包括函数）都不会被重用。由于可以使用松散类型的方式编写函数，因此没有理由不能被多个对象实例共享。</li>
<li>原型模式考虑了这一点，使用构造函数的prototype属性分配应共享的属性和方法。 构造函数/原型组合模式使用构造函数定义实例属性，使用原型模式定义共享属性和方法。</li>
</ul>
<p>JavaScript中的继承主要使用原型链接的概念来实现。 原型链涉及将构造函数的原型分配为另一种类型的实例。 这样做时，子类型采用类似于基于类的继承的方式假定超类型的所有属性和方法。 原型链的问题在于，所有继承的属性和方法在对象实例之间共享，这使其不适合单独使用。 构造函数窃取模式避免了这些问题，它从子类型的构造函数内部调用了父类型的构造函数。 这允许每个实例具有其自己的属性，但是强制仅使用构造函数模式来定义类型。 最受欢迎的继承模式是组合继承，它使用原型链继承共享的属性和方法，并使用构造函数窃取来继承实例属性。</p>
<p>还有以下替代继承模式：</p>
<ul>
<li>原型继承无需预先定义的构造函数即可实现继承，实质上是对给定对象执行浅表克隆操作。然后可以进一步增加运算结果。</li>
<li>密切相关的是寄生继承，这是一种基于另一个对象或某些信息创建对象，对其进行扩充并返回的模式。 此模式也已重新用于结合继承，以消除与调用超类型构造函数的次数有关的效率低下的问题。</li>
<li>寄生组合继承被认为是实现基于类型的继承的最有效方法。</li>
</ul>
<p>ECMAScript 6中的新功能是引入了类，这些类在很大程度上是现有的基于原型的概念的语法包装。该语法使该语言能够优雅地定义向后兼容的类，并且可以从内置或自定义类继承。类优雅地弥合了对象实例，对象原型和对象类之间的鸿沟。</p>
<h2 id="9代理与反思">9、代理与反思</h2>
<h3 id="小结-8">小结</h3>
<p>代理是ECMAScript 6规范中最令人兴奋和动态的添加之一。尽管它们没有向后编译支持，但它们启用了元编程和抽象的全新领域，而以前是不存在的。</p>
<p>从高层次看，代理是真实JavaScript对象的透明虚拟化。 创建代理后，您可以定义一个包含陷阱的处理程序对象，陷阱是几乎所有基本JavaScript运算符和方法都会遇到的拦截点。这些陷阱处理程序允许您修改这些基本方法的操作方式，尽管它们受陷阱不变式约束。</p>
<p>代理旁边还有Reflect API，它提供了一套方法，这些方法相同地封装了每个陷阱正在拦截的行为。Reflect API可以被视为基本操作的集合，这些基本操作是几乎所有JavaScript对象API的构造块。</p>
<p>代理的效用几乎是无限的，它使开发人员可以运用优雅的新模式，例如（但不限于）跟踪属性访问，隐藏属性，防止对属性的修改或删除，功能参数验证，构造函数参数验证，数据约束力和可观察性。</p>
<h2 id="10函数">10、函数</h2>
<h3 id="小结-9">小结</h3>
<p>函数是JavaScript编程中有用且通用的工具。ECMAScript 6引入了强大的语法，使您可以更有效地使用它们。</p>
<ul>
<li>函数表达式与函数声明不同。函数声明需要名称，而函数表达式则不需要。没有名称的函数表达式也称为匿名函数。</li>
<li>箭头函数是ES6中的新功能，与函数表达式相似，但有一些重要区别。</li>
<li>JavaScript函数中的参数和参数非常灵活。arguments对象以及ES6中新的散布运算符允许完全动态的定义和调用。</li>
<li>在内部，函数公开了一些对象和引用，这些对象和引用为您提供有关如何调用该函数，在何处调用该函数以及最初传递给它的信息。</li>
<li>引擎将通过尾调用来优化功能，以保留栈空间。</li>
<li>在幕后，闭包的作用域链包含一个变量对象，包含函数和全局上下文。</li>
<li>通常，函数完成执行后会破坏函数的作用域及其所有变量。</li>
<li>从该函数返回闭包时，其范围将保留在内存中，直到闭包不再存在为止。</li>
<li>可以立即创建并调用一个函数，执行其中的代码，但永远不要留下对该函数的引用。</li>
<li>这将导致函数内部的所有变量被破坏，除非将它们专门设置为包含作用域中的变量。</li>
<li>即使JavaScript没有私有对象属性的正式概念，闭包也可以用来实现可访问包含范围内定义的变量的公共方法。</li>
<li>可以访问私有变量的公共方法称为特权方法。</li>
<li>可以使用构造函数或原型模式在自定义类型上实现特权方法，而使用模块或模块扩展模式可以在单例上实现特权方法。</li>
</ul>
<h2 id="11承诺和异步功能">11、承诺和异步功能</h2>
<h3 id="小结-10">小结</h3>
<p>长期以来，在单线程JavaScript运行时内部掌握异步行为一直是一项艰巨的任务。随着ES6的Promise和ES7的 async/await 的引入，ECMAScript中的异步构造得到了极大的增强。Promise和async/await不仅启用了以前难以实现或无法实现的模式，而且还带来了一种全新的JavaScript编写方式，该方式更加简洁，简短，易于理解和调试。</p>
<p>构建承诺是为了提供围绕异步代码的简洁抽象。它们可以表示异步执行的代码块，但也可以表示异步计算的值。 在需要序列化异步代码块的情况下，它们特别有用。 承诺是一个令人愉快的可塑结构：它们可以序列化，链接，组合，扩展和重组。</p>
<p>异步函数是将promise范式应用于JavaScript函数的结果。它们引入了在不阻塞执行主线程的情况下挂起函数执行的功能。它们在编写可读的以承诺为中心的代码以及管理异步代码的序列化和并行化方面都非常有用。它们是现代JavaScript工具箱中最重要的工具之一。</p>
<h2 id="12浏览器对象模型">12、浏览器对象模型</h2>
<h3 id="小结-11">小结</h3>
<p>浏览器对象模型（BOM）基于窗口对象，该窗口对象表示浏览器窗口和可见页面区域。 窗口对象是ECMAScript全局对象的两倍，因此所有全局变量和函数都将成为其属性，并且所有本机构造函数和函数最初都存在于其上。本章讨论了BOM的以下元素：</p>
<ul>
<li>要引用其他窗口对象，有几个窗口指针。</li>
<li>location对象允许通过编程方式访问浏览器的导航系统。通过设置属性，可以逐段或完全更改浏览器的URL。</li>
<li>replace（）方法允许导航到新的URL并替换浏览器历史记录中当前显示的页面。</li>
<li>navigator对象提供有关浏览器的信息。提供的信息类型在很大程度上取决于所使用的浏览器，尽管某些通用属性（例如userAgent）在所有浏览器中都可用。</li>
</ul>
<p>BOM中可用的其他两个对象执行的功能非常有限。screen对象提供有关客户端显示的信息。此信息通常用于网站的指标收集。history对象提供了对浏览器历史记录堆栈的有限浏览，允许开发人员确定历史记录堆栈中有多少个站点，并使他们能够返回或前进到历史记录中的任何页面，以及修改历史记录堆栈。</p>
<h2 id="13客户端检测">13、客户端检测</h2>
<h3 id="小结-12">小结</h3>
<p>客户端检测是JavaScript中最具争议的主题之一。由于浏览器的差异，通常有必要基于浏览器的功能来分叉代码。有几种检测客户端的方法，但以下两种最常用：</p>
<ul>
<li>功能检测-在使用特定浏览器功能之前进行测试。例如，脚本可以在调用函数之前检查其是否存在。这种方法使开发人员不必担心特定的浏览器类型和版本，从而使他们能够专注于功能是否存在。功能检测无法准确检测特定的浏览器或版本。</li>
<li>用户代理检测-通过查看浏览器的用户代理字符串来识别浏览器。useragent字符串包含有关浏览器的大量信息，通常包括浏览器，平台，操作系统和浏览器版本。用户代理字符串的开发已有很长的历史，浏览器供应商试图欺骗网站，使他们认为自己是另一个浏览器。用户代理检测可能很棘手，特别是在处理Opera屏蔽其用户代理字符串的功能时。即使这样，useragent字符串也可以确定正在使用的渲染引擎以及运行它的平台，包括移动设备和游戏系统。</li>
</ul>
<p>在决定使用哪种客户端检测方法时，最好先使用功能检测。奇怪的检测是确定代码应该如何进行的第二选择。用户代理检测被认为是客户端检测的最后选择，因为它非常依赖于用户代理字符串。</p>
<p>浏览器还提供了围绕它的软件和硬件的日益广泛的画面。通过屏幕和导航器对象，可以得出关于操作系统，浏览器，硬件，设备位置，电池状态以及各种其他主题的极其准确的想法。</p>
<h2 id="14文档对象模型">14、文档对象模型</h2>
<h3 id="小结-13">小结</h3>
<p>文档对象模型（DOM）是与语言无关的API，用于访问和处理HTML和XML文档。DOM级别1将HTML和XML文档表示为节点的层次结构，可以使用JavaScript对其进行操作以更改基础文档的外观和结构。</p>
<p>DOM由一系列节点类型组成，如下所述：</p>
<ul>
<li>基本节点类型是Node，它是文档各个部分的抽象表示； 所有其他类型都继承自Node。</li>
<li>Document类型代表整个文档，并且是层次结构的根节点。 在JavaScript中，文档对象是Document的实例，它允许以多种不同方式查询和检索节点。</li>
<li>元素节点表示文档中的所有HTML或XML元素，可用于操纵其内容和属性。</li>
<li>存在其他节点类型，用于文本内容，注释，文档类型，CDATA部分和文档片段。</li>
</ul>
<p>尽管使用&lt;script&gt;和&lt;style&gt;元素通常会很复杂，但是DOM访问在大多数情况下都能按预期工作。 由于这些元素分别包含脚本和样式信息，因此它们在浏览器中的处理方式通常不同于其他元素。</p>
<p>关于DOM可能最重要的了解是它如何影响整体性能。DOM操作是可以在JavaScript中完成的一些最昂贵的操作，其中NodeList对象特别麻烦。NodeList对象是“活动的”，这意味着每次访问该对象时都会运行查询。由于这些问题，最好最大程度地减少DOM操作的数量。</p>
<p>引入了MutationObserver来代替性能较差的MutationEvent。它允许使用相对简单的API进行高效且精确的DOM突变监控。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Single Long</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-10-21
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://slkyrim.github.io/tags/javascript/">JavaScript</a>
          <a href="https://slkyrim.github.io/tags/english/">English</a>
          <a href="https://slkyrim.github.io/tags/%E8%8B%B1%E8%AF%AD/">英语</a>
          <a href="https://slkyrim.github.io/tags/copytranslator/">CopyTranslator</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/leetcode_20201018_weekly/">
            <span class="next-text nav-default">Leetcode_20201018_Weekly</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "SLKyrim/comments-for-myBlog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:623962644@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/SLKyrim" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://slkyrim.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Single Long
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>

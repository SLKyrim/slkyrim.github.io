<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>《精通 C# 7》(2017版)阅读记录 - Single Long</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Single Long" />
  <meta name="description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应" />

  <meta name="keywords" content="Single Long, Blog" />






<meta name="generator" content="Hugo 0.74.3" />


<link rel="canonical" href="https://slkyrim.github.io/post/book_pro_csharp_7/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="《精通 C# 7》(2017版)阅读记录" />
<meta property="og:description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://slkyrim.github.io/post/book_pro_csharp_7/" />
<meta property="article:published_time" content="2020-12-02T11:00:41+08:00" />
<meta property="article:modified_time" content="2020-12-03T15:03:38+08:00" />
<meta itemprop="name" content="《精通 C# 7》(2017版)阅读记录">
<meta itemprop="description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应">
<meta itemprop="datePublished" content="2020-12-02T11:00:41+08:00" />
<meta itemprop="dateModified" content="2020-12-03T15:03:38+08:00" />
<meta itemprop="wordCount" content="18109">



<meta itemprop="keywords" content="C#,WPF,CopyTranslator," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《精通 C# 7》(2017版)阅读记录"/>
<meta name="twitter:description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">龍</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      龍
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">《精通 C# 7》(2017版)阅读记录</h1>
      
      <div class="post-meta">
        <time datetime="2020-12-02" class="post-time">
          2020-12-02
        </time>
        <div class="post-category">
            <a href="https://slkyrim.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/"> 技术书籍 </a>
            
          </div>
        <span class="more-meta"> 约 18109 字 </span>
          <span class="more-meta"> 预计阅读 37 分钟 </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第vii部分-windows-presentation-foundation">第VII部分 Windows Presentation Foundation</a>
      <ul>
        <li><a href="#第24章-windows-presentation-foundation和xaml简介">第24章 Windows Presentation Foundation和XAML简介</a></li>
        <li><a href="#研究wpf程序集">研究WPF程序集</a></li>
        <li><a href="#了解wpf-xaml的语法">了解WPF XAML的语法</a></li>
        <li><a href="#浏览wpf文档">浏览WPF文档</a></li>
        <li><a href="#概要">概要</a></li>
      </ul>
    </li>
    <li><a href="#wpf控件布局事件和数据绑定">WPF控件，布局，事件和数据绑定</a>
      <ul>
        <li><a href="#wpf核心控件概述">WPF核心控件概述</a></li>
        <li><a href="#使用面板控制内容布局">使用面板控制内容布局</a></li>
        <li><a href="#使用嵌套面板构建窗口框架">使用嵌套面板构建窗口框架</a></li>
        <li><a href="#了解wpf命令">了解WPF命令</a></li>
        <li><a href="#了解路由事件">了解路由事件</a></li>
        <li><a href="#深入了解wpf-api和控件">深入了解WPF API和控件</a></li>
        <li><a href="#概要-1">概要</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="pro-c-7-with-net-and-net-core---andrew-troelsen-et-al">Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al.</h1>
<h2 id="第vii部分-windows-presentation-foundation">第VII部分 Windows Presentation Foundation</h2>
<h3 id="第24章-windows-presentation-foundation和xaml简介">第24章 Windows Presentation Foundation和XAML简介</h3>
<p>当.NET平台的1.0版发布时，需要构建图形桌面应用程序的程序员使用了两个API，它们分别名为Windows Forms和GDI+，这些API主要打包在System.Windows.Forms.dll和System.Drawing.dll程序集。尽管Windows Forms / GDI+仍然是用于构建传统桌面GUI的可行API，但是Microsoft从.NET 3.0版本开始提供了另一种名为Windows Presentation Foundation（WPF）的GUI桌面API。</p>
<p>WPF最初的这一章首先探讨了这个新GUI框架背后的动机，这将帮助您了解Windows Forms / GDI+和WPF编程模型之间的区别。接下来，您将了解几个重要类的角色，包括Application，Window，ContentControl，Control，UIElement和FrameworkElement。</p>
<p>然后，本章将向您介绍名为Extensible Application Markup Language（XAML；发音为“ zammel”）的基于XML的语法。在这里，您将学习XAML的语法和语义（包括附加的属性语法以及类型转换器和标记扩展的作用）</p>
<p>本章最后通过构建第一个WPF应用程序来研究Visual Studio的集成WPF设计器。在这段时间里，您将学习如何拦截键盘和鼠标活动，定义应用程序范围的数据以及执行其他常见的WPF任务。</p>
<h4 id="wpf背后的动机">WPF背后的动机</h4>
<p>多年来，Microsoft创建了许多图形用户界面工具包（原始C/C++/Windows API开发，VB6，MFC等）来构建桌面可执行文件。 这些API均提供了一个代码库来表示GUI应用程序的基本方面，包括主窗口，对话框，控件，菜单系统和其他基本必需品。 随着.NET平台的最初发行，Windows Forms API凭借其简单而强大的对象模型迅速成为UI开发的首选模型。</p>
<p>尽管已经使用Windows Forms成功创建了许多功能齐全的桌面应用程序，但事实是该编程模型相当不对称。简而言之，System.Windows.Forms.dll和System.Drawing.dll不为构建功能丰富的桌面应用程序所需的许多其他技术提供直接支持。为了说明这一点，请考虑WPF发行之前的GUI桌面开发的特殊性质（请参阅表24-1）。</p>
<p>如您所见，Windows Forms开发人员必须从许多不相关的API和对象模型中提取类型。虽然在语法上看起来确实可以使用这些不同的API（毕竟只是C＃代码），但是您可能还同意每种技术都需要完全不同的思维方式。例如，使用DirectX创建3D渲染动画所需的技能与用于将数据绑定到网格的技能完全不同。可以肯定的是，Windows Forms程序员很难掌握每个API的多样性。</p>
<h4 id="统一各种api">统一各种API</h4>
<p>创建WPF的目的是将这些以前不相关的编程任务合并到一个统一的对象模型中。因此，如果您需要编写3D动画，则无需针对DirectX API进行手动编程（尽管可以），因为3D功能直接包含在WPF中。若要查看清理情况，请考虑表24-2，该表说明了从.NET 3.0开始引入的桌面开发模型。</p>
<p>显而易见的好处是，.NET程序员现在拥有一个对称的API，可以满足所有常见的GUI桌面编程需求。当您对主要的WPF程序集的功能和XAML的语法感到满意之后，您会惊讶地发现创建复杂UI的速度如此之快。</p>
<h4 id="通过xaml提供关注点分离">通过XAML提供关注点分离</h4>
<p>也许最引人注目的好处之一是WPF提供了一种将GUI应用程序的外观与驱动它的编程逻辑完全分开的方法。使用XAML，可以通过XML标记定义应用程序的UI。然后可以将此标记（最好使用Microsoft Visual Studio或Microsoft Expression Blend等工具生成）连接到相关的C＃代码文件，以提供程序的实质功能。</p>
<blockquote>
<p>注意: XAML不限于WPF应用程序。任何应用程序都可以使用XAML来描述.NET对象树，即使它们与可见的用户界面无关。</p>
</blockquote>
<p>在研究WPF时，您可能会惊讶于此“桌面标记”提供的灵活性。XAML不仅使您可以在标记中定义简单的UI元素（按钮，网格，列表框等），而且还可以定义交互式2D和3D图形，动画，数据绑定逻辑以及多媒体功能（例如视频播放）。</p>
<p>XAML还使自定义控件如何呈现其视觉外观变得容易。例如，定义使公司徽标具有动画效果的圆形按钮控件仅需要几行标记。如第27章所示，可以通过样式和模板来修改WPF控件，使您能够以最小的麻烦和麻烦来更改应用程序的整体外观。 与Windows Forms开发不同，从头开始构建自定义WPF控件的唯一令人信服的理由是，如果您需要更改控件的行为（例如，添加自定义方法，属性或事件；子类化现有控件以覆盖虚拟成员）。如果您只需要更改控件的外观（例如，圆形动画按钮），则可以完全通过标记进行更改。</p>
<h4 id="提供优化的渲染模型">提供优化的渲染模型</h4>
<p>GUI工具包（例如Windows Forms，MFC或VB6）使用基于C的低级API（GDI）来执行所有图形渲染请求（包括UI元素（如按钮和列表框）的渲染）。 Windows操作系统已有多年历史。GDI为典型的业务应用程序或简单的图形程序提供了足够的性能；但是，如果需要UI应用程序来利用高性能图形，则需要DirectX。</p>
<p>WPF编程模型的不同之处在于，呈现图形数据时不使用GDI。现在，所有渲染操作（例如2D图形，3D图形，动画，控件渲染等）都使用DirectX API。第一个明显的好处是您的WPF应用程序将自动利用硬件和软件优化。 同样，WPF应用程序可以利用非常丰富的图形服务（模糊效果，抗锯齿，透明度等），而无需直接针对DirectX API进行编程的复杂性。</p>
<blockquote>
<p>注意: 尽管WPF确实将所有渲染请求都推送到DirectX层，但我不想建议WPF应用程序的执行速度与直接使用非托管C++和DirectX构建应用程序的速度一样快。尽管.NET 4.7中的WPF已经取得了显着进步，但是如果您打算构建需要最快执行速度的桌面应用程序（例如3D视频游戏），则非托管C++和DirectX仍然是最好的方法。</p>
</blockquote>
<h4 id="简化复杂的ui编程">简化复杂的UI编程</h4>
<p>到目前为止，总而言之，Windows Presentation Foundation（WPF）是用于构建桌面应用程序的API，该API将各种桌面API集成到单个对象模型中，并通过XAML清晰地分离了关注点。除了这些要点之外，WPF应用程序还受益于一种将服务集成到程序中的简单方法，这在过去一直很复杂。以下是WPF核心功能的简要介绍：</p>
<ul>
<li>许多布局管理器（远远超过Windows窗体）提供了对内容放置和重新放置的极其灵活的控制。</li>
<li>使用增强的数据绑定引擎以多种方式将内容绑定到UI元素。</li>
<li>内置样式引擎，使您可以为WPF应用程序定义“主题”。</li>
<li>使用矢量图形，可以自动调整内容大小以适合承载应用程序的屏幕的大小和分辨率。</li>
<li>支持2D和3D图形，动画以及视频和音频播放。</li>
<li>丰富的排版API，例如对XML Paper Specification（XPS）文档，固定文档（WYSIWYG），流程文档和文档注释的支持（例如，Sticky Notes API）。</li>
<li>支持与旧版GUI模型（例如Windows Forms，ActiveX和Win32 HWND）进行互操作。例如，您可以将自定义Windows Forms控件合并到WPF应用程序中，反之亦然。</li>
</ul>
<p>现在，您已经了解了WPF的功能，让我们看一下可以使用此API创建的各种类型的应用程序。 这些功能中的许多功能将在以后的章节中详细探讨。</p>
<h3 id="研究wpf程序集">研究WPF程序集</h3>
<p>WPF最终不过是.NET程序集中捆绑在一起的类型的集合而已。表24-3描述了用于构建WPF应用程序的关键程序集，在创建新项目时必须引用每个程序集。如您所愿，Visual Studio WPF项目会自动引用这些必需的程序集。</p>
<p>表24-3中这四个程序集共同定义了许多新的名称空间以及数百种新的.NET类，接口，结构，枚举和委托。 尽管应该查阅.NET Framework 4.7 SDK文档以获取完整的详细信息，但表24-4描述了一些（但不是全部）重要名称空间的作用。</p>
<p>为了开始使用WPF编程模型，您将检查System.Windows命名空间的两个成员：Application和Window，它们是任何传统桌面开发工作中常见的。</p>
<blockquote>
<p>注意：如果使用Windows Forms API创建了桌面UI，请注意System.Windows.Forms.* 和System.Drawing.*程序集与WPF不相关。这些库代表原始的.NET GUI工具包Windows Forms / GDI+。</p>
</blockquote>
<h4 id="application类的作用">Application类的作用</h4>
<p>System.Windows.Application类表示正在运行的WPF应用程序的全局实例。此类提供了Run()方法（用于启动应用程序），一系列事件，您可以处理这些事件以与应用程序的生命周期进行交互（例如Startup和Exit），以及一些特定于XAML浏览器应用程序（例如，当用户在页面之间导航时触发的事件）。 表24-5详细列出了一些关键属性。</p>
<h4 id="构造application类">构造Application类</h4>
<p>任何WPF应用程序都需要定义一个扩展Application的类。 在此类中，您将定义程序的入口点（Main（）方法），该入口点创建此子类的实例，并通常处理Startup和Exit事件（必要时）。 这是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="c1">// Define the global application object for this WPF program.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">MyApp</span> <span class="p">:</span> <span class="n">Application</span>
<span class="p">{</span>
<span class="na">    [STAThread]</span>
    <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Create the application object.
</span><span class="c1"></span>        <span class="n">MyApp</span> <span class="n">app</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyApp</span><span class="p">();</span>
        <span class="c1">// Register the Startup/Exit events.
</span><span class="c1"></span>        <span class="n">app</span><span class="p">.</span><span class="n">Startup</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* Start up the app */</span> <span class="p">};</span>
        <span class="n">app</span><span class="p">.</span><span class="n">Exit</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* Exit the app */</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在启动处理程序中，您通常会处理所有传入的命令行参数并启动程序的主窗口。如您所料，可以在Exit处理程序中编写该程序的任何必要关闭逻辑（例如，保存用户首选项，写入Windows注册表）。</p>
<blockquote>
<p>注意: WPF应用程序的Main（）方法必须具有[STAThread]属性，该属性可确保您的应用程序使用的所有旧COM对象都是线程安全的。如果不以这种方式注释Main（），则会遇到运行时异常。</p>
</blockquote>
<h4 id="枚举windows集合">枚举Windows集合</h4>
<p>应用程序公开的另一个有趣的属性是Windows，它提供对表示当前WPF应用程序加载到内存中的每个窗口的集合的访问。回想一下，当您创建新的Window对象时，它们会自动添加到Application.Windows集合中。这是一个示例方法，该方法将最小化应用程序的每个窗口（可能响应最终用户触发的给定键盘手势或菜单选项）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="c1">// Define the global application object for this WPF program.
</span><span class="c1"></span><span class="k">static</span> <span class="k">void</span> <span class="n">MinimizeAllWindows</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">Window</span> <span class="n">wnd</span> <span class="k">in</span> <span class="n">Application</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Windows</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">wnd</span><span class="p">.</span><span class="n">WindowState</span> <span class="p">=</span> <span class="n">WindowState</span><span class="p">.</span><span class="n">Minimized</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>您将很快构建一些WPF应用程序，但是在此之前，让我们检查一下Window类型的核心功能，并在此过程中了解许多重要的WPF基类。</p>
<h4 id="窗口类的作用">窗口类的作用</h4>
<p>System.Windows.Window类（位于PresentationFramework.dll程序集中）表示由Application派生的类拥有的单个窗口，包括主窗口显示的所有对话框。毫不奇怪，Window有一系列父类，每个父类都为表带来了更多功能。请考虑图24-1，该图显示了通过Visual Studio对象浏览器看到的System.Windows.Window的继承链（和实现的接口）。</p>
<!-- raw HTML omitted -->
<p>在学习本章及以后的各章时，您将了解这些基本类提供的功能。但是，为激起您的胃口，以下各节提供了每个基类提供的功能的细分（有关详细信息，请查阅.NET Framework 4.7 SDK文档）。</p>
<h4 id="systemwindowscontrolscontentcontrol的角色">System.Windows.Controls.ContentControl的角色</h4>
<p>Window的直接父级是ContentControl，它很可能是所有WPF类中最诱人的。此基类为派生类型提供了承载单个内容的能力，简单地说，就是通过Content属性引用放置在控件表面区域内部的可视数据。WPF内容模型使自定义内容控件的基本外观非常简单。</p>
<p>例如，当您想到典型的“按钮”控件时，您倾向于假定内容是简单的字符串文字（“确定”，“取消”，“中止”等）。 如果您使用XAML来描述WPF控件，并且想要分配给Content属性的值可以作为一个简单的字符串捕获，则可以在元素的开头定义内设置Content属性（不要担心确切的含义）。 标记）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Setting the Content value in the opening element --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：Content属性也可以用C＃代码设置，这使您可以在运行时更改控件的内部。</p>
</blockquote>
<p>但是，内容几乎可以是任何东西。例如，假设您想要一个“按钮”，其功能比简单的字符串（也许是自定义图形和文本模糊）更有趣。在其他UI框架（例如Windows Forms）中，将要求您构建自定义控件，这可能需要大量代码并需要维护一个全新的类。使用WPF内容模型，无需这样做。</p>
<p>如果您想将Content属性分配给无法以简单字符数组捕获的值，则无法使用控件的开始定义中的属性来分配它。相反，您必须在元素范围内隐式定义内容数据。 例如，以下 &lt;Button&gt; 包含 &lt;StackPanel&gt; 作为内容，其本身包含一些唯一的数据（准确地说是&lt;Ellipse&gt;和&lt;Label&gt;）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Implicitly setting the Content property with complex data --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Red&#34;</span> <span class="na">Width=</span><span class="s">&#34;25&#34;</span> <span class="na">Height=</span><span class="s">&#34;25&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;OK!&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>您还可以使用XAML的属性元素语法来设置复杂的内容。考虑下面的功能上等效的&lt;Button&gt;定义，该定义使用property-element语法显式设置了Content属性（同样，您将在本章后面找到有关XAML的更多信息，因此，请不要花太多时间在细节上）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Setting the Content property using property-element syntax --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Content&gt;</span>
        <span class="nt">&lt;StackPanel&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Red&#34;</span> <span class="na">Width=</span><span class="s">&#34;25&#34;</span> <span class="na">Height=</span><span class="s">&#34;25&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;OK!&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
    <span class="nt">&lt;/Button.Content&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，并非每个WPF元素都派生自ContentControl，因此，并非所有控件都支持此唯一的内容模型（但是，大多数控件都支持）。同样，某些WPF控件对您刚刚检查过的基本内容模型进行了一些改进。第25章将更详细地研究WPF内容的作用。</p>
<h4 id="systemwindowscontrolscontrol的角色">System.Windows.Controls.Control的角色</h4>
<p>与ContentControl不同，所有WPF控件均作为通用父级共享Control基类。该基类提供了许多基本的UI功能核心成员。例如，控件定义属性以建立控件的大小，不透明度，标签顺序逻辑，显示光标，背景颜色等。此外，此父类为模板服务提供支持。如第27章所述，WPF控件可以使用模板和样式完全改变其呈现外观的方式。表24-6列出了Control类型的一些关键成员，按相关功能分组。</p>
<h4 id="systemwindowsframeworkelement的角色">System.Windows.FrameworkElement的角色</h4>
<p>此基类提供了许多在WPF框架中使用的成员，例如对情节提要（在动画中使用）的支持和对<strong>数据绑定</strong>的支持，以及（通过Name属性）命名成员的能力，以获得任何由派生类型定义的资源，并建立派生类型的整体尺寸。表24-7列出了重点内容。</p>
<h4 id="systemwindowsuielement的角色">System.Windows.UIElement的角色</h4>
<p>在Window的继承链中的所有类型中，UIElement基类提供了最多的功能。UIElement的关键任务是为派生类型提供大量事件，以允许派生类型接收焦点并处理输入请求。例如，此类提供大量事件来说明拖放操作，鼠标移动，键盘输入和手写笔输入（适用于Pocket PC和Tablet PC）。</p>
<p>第25章详细探讨了WPF事件模型。但是，许多核心事件看起来都很熟悉（MouseMove，KeyUp，MouseDown，MouseEnter，MouseLeave等）。除了定义数十个事件外，该父类还提供了许多属性来说明控件焦点，启用状态，可见性和命中测试逻辑，如表24-8所示。</p>
<h4 id="systemwindowsthreadingdispatcherobject的角色">System.Windows.Threading.DispatcherObject的角色</h4>
<p>Window类型的最后一个基类（超出System.Object，我认为在书中此刻不需要进一步说明）是DispatcherObject。此类型提供一个有用的属性Dispatcher，该属性返回关联的System.Windows.Threading.Dispatcher对象。<strong>Dispatcher类是WPF应用程序事件队列的入口点，它提供了处理并发和线程的基本构造</strong>。</p>
<h3 id="了解wpf-xaml的语法">了解WPF XAML的语法</h3>
<p>生产级WPF应用程序通常将使用专用工具来生成必要的XAML。尽管这些工具很有用，但了解XAML标记的整体结构是一个好主意。为了帮助您进行学习，请允许我介绍一种流行的（免费的）工具，该工具可让您轻松地尝试XAML。</p>
<h4 id="介绍kaxaml">介绍Kaxaml</h4>
<p>当您第一次学习XAML语法时，使用名为Kaxaml的免费工具会有所帮助。您可以从可下载文件中的Kaxaml目录中获得此流行的XAML编辑器/解析器。</p>
<blockquote>
<p>注意：对于本书的许多版本，我都已将用户指向 <a href="http://www.kaxaml.com">www.kaxaml.com</a>，但不幸的是，该站点已淘汰。我在本书的可下载材料中拥有.msi软件包的副本，并且还将存储库分叉到了我的个人GitHub帐户（www.github.com/skimedic/kaxaml ），以确保它可以继续使用。非常感谢并感谢Kaxaml的开发人员；这是一个很棒的工具，已帮助无数开发人员学习XAML。</p>
</blockquote>
<p>Kaxaml很有帮助，因为它不了解C＃源代码，事件处理程序或实现逻辑。与使用成熟的Visual Studio WPF项目模板相比，它是测试XAML代码片段的直接得多的方法。同样，Kaxaml具有许多集成工具，例如颜色选择器，XAML代码段管理器，甚至是“XAML清理程序”选项，这些选项都将根据您的设置来格式化XAML。首次打开Kaxaml时，将为Page控件找到简单的标记，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>

    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>类似于Window，Page包含各种布局管理器和控件。但是，与Window不同，Page对象不能作为独立实体运行。 而是必须将它们放置在合适的主机内，例如NavigationWindow或Frame。好消息是您可以在Page或Window范围内键入相同的标记。</p>
<p>作为初始测试，请在工具底部的XAML窗格中输入以下标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- A button with custom content --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;100&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Green&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，您应该在Kaxaml编辑器的上部看到页面渲染（参见图24-2）。</p>
<!-- raw HTML omitted -->
<p>当您使用Kaxaml时，请记住，该工具不允许您编写任何需要代码编译的标记（但是，允许使用x：Name）。 这包括定义x：Class属性（用于指定代码文件），在标记中输入事件处理程序名称，或使用也需要进行代码编译的任何XAML关键字（例如FieldModifier或ClassModifier）。任何尝试这样做都会导致标记错误。</p>
<h4 id="xaml-xml命名空间和xaml关键字">XAML XML命名空间和XAML“关键字”</h4>
<p>WPF XAML文档的根元素（例如Window，Page，UserControl或Application定义）几乎总是引用以下两个预定义的XML名称空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
    
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>第一个XML名称空间: <a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a> 映射了一系列WPF .NET名称空间（System.Windows，System.Windows.Controls，System.Windows.Data，System.Windows.Ink，System.Windows.Media等），提供给当前的 *.xaml文件。</p>
<p>实际上，此一对多映射是使用程序集级[XmlnsDefinition]属性在WPF程序集（WindowsBase.dll，PresentationCore.dll和PresentationFramework.dll）中进行硬编码的。例如，如果打开Visual Studio对象浏览器并选择PresentationCore.dll程序集，您将看到诸如以下的清单，这些清单实际上导入了System.Windows：</p>
<blockquote>
<p>[assembly: XmlnsDefinition(&ldquo;http://schemas.microsoft.com/winfx/2006/xaml/presentation&rdquo;,
&ldquo;System.Windows&rdquo;)]</p>
</blockquote>
<p>第二个XML名称空间 <a href="http://schemas.microsoft.com/winfx/2006/xaml">http://schemas.microsoft.com/winfx/2006/xaml</a> ，用于包括XAML专用的“关键字”（由于缺乏更好的用语），以及包含System.Windows.Markup名称空间，如下所示：</p>
<blockquote>
<p>[assembly: XmlnsDefinition(&ldquo;http://schemas.microsoft.com/winfx/2006/xaml&rdquo;,
&ldquo;System.Windows.Markup&rdquo;)]</p>
</blockquote>
<p>任何格式正确的XML文档（请记住，XAML是基于XML的语法）的一个规则是，开头的根元素将一个XML名称空间指定为主名称空间，该名称空间通常是包含最常用项目的名称空间。如果根元素要求包含其他辅助名称空间（如此处所示），则必须使用唯一的标记前缀定义它们（以解决任何可能的名称冲突）。按照惯例，前缀只是x；但是，这可以是您需要的任何唯一令牌，例如XamlSpecificStuff。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:XamlSpecificStuff=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- A button with custom content --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">XamlSpecificStuff:Name=</span><span class="s">&#34;button1&#34;</span> <span class="na">Height=</span><span class="s">&#34;100&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Green&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>定义冗长的XML名称空间前缀的明显缺点是，每次您的XAML文件需要引用此XML名称空间中定义的项之一时，都需要键入XamlSpecificStuff。鉴于XamlSpecificStuff需要许多其他的击键，只要坚持使用x替代即可。</p>
<p>无论如何，除了x:Name，x:Class和x:Code关键字之外，http//schemas.microsoft.com/winfx/2006/xaml XML命名空间还提供对其他XAML关键字（最常见的XAML关键字）的访问权限 如表24-9所示。</p>
<table>
<thead>
<tr>
<th align="center">XAML关键字</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">x:Array</td>
<td align="left">表示XAML中的.NET数组类型</td>
</tr>
<tr>
<td align="center">x:ClassModifier</td>
<td align="left">允许您定义由Class关键字表示的C＃类（内部或公共）的可见性。</td>
</tr>
<tr>
<td align="center">x:FieldModifier</td>
<td align="left">允许您为根的任何命名子元素（例如，Window元素中的Button）定义类型成员（内部，公共，私有或受保护）的可见性。 使用Name XAML关键字定义命名元素。</td>
</tr>
<tr>
<td align="center">x:Key</td>
<td align="left">允许您为XAML项目建立键值，该键值将放入字典元素中。</td>
</tr>
<tr>
<td align="center">x:Name</td>
<td align="left">允许您指定给定XAML元素的生成的C＃名称</td>
</tr>
<tr>
<td align="center">x:Null</td>
<td align="left">表示空引用</td>
</tr>
<tr>
<td align="center">x:Static</td>
<td align="left">允许您引用类型的静态成员</td>
</tr>
<tr>
<td align="center">x:Type</td>
<td align="left">等效于C＃typeof运算符的XAML（它将根据提供的名称生成System.Type）</td>
</tr>
<tr>
<td align="center">x:TypeArguments</td>
<td align="left">允许您将元素建立为具有特定类型参数的泛型类型</td>
</tr>
</tbody>
</table>
<p>除了这两个必需的XML名称空间声明之外，有可能（有时是必要的）在XAML文档的开始元素中定义其他标签前缀。通常，每当需要在XAML中描述外部程序集中定义的.NET类时，都需要这样做。</p>
<p>例如，假设您已经构建了一些自定义WPF控件，并将它们打包在一个名为MyControls.dll的库中。现在，如果要创建一个使用这些控件的新Window，则可以建立一个自定义XML名称空间，该名称空间<strong>使用clr-namespace和Assembly令牌映射到您的库</strong>。以下是一些示例标记，这些标记创建了名为myCtrls的标记前缀，可用于访问库中的控件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">&#34;WpfApplication1.MainWindow&#34;</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
    <span class="na">xmlns:myCtrls=</span><span class="s">&#34;clr-namespace:MyControls;assembly=MyControls&#34;</span>
    <span class="na">Title=</span><span class="s">&#34;MainWindow&#34;</span> <span class="na">Height=</span><span class="s">&#34;350&#34;</span> <span class="na">Width=</span><span class="s">&#34;525&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;myCtrls:MyCustomControl</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>将<strong>clr-namespace令牌</strong>分配给程序集中.NET命名空间的名称，而将<strong>程序集(assembly)令牌</strong>设置为外部*.dll程序集的友好名称。您可以对要在标记中使用的任何外部.NET库使用此语法。尽管目前不需要这样做，但以后的章节将要求您定义自定义XML名称空间声明以描述标记中的类型。</p>
<blockquote>
<p>注意：如果需要在标记中定义一个类，该类是当前程序集的一部分，但在其他.NET命名空间中，则不带assembly= 属性定义xmlns标记前缀，如下所示：
xmlns:myCtrls=&quot;clr-namespace:SomeNamespaceInMyApp&rdquo;</p>
</blockquote>
<h4 id="控制类和成员变量可见性">控制类和成员变量可见性</h4>
<p>在以后的章节中，您会看到许多这样的关键字在起作用。但是，通过一个简单的示例，请考虑以下使用ClassModifier和FieldModifier关键字以及X:Name和x:Class定义的XAML &lt;Window&gt;（请记住，kaxaml.exe将不允许您使用需要代码编译的任何XAML关键字，例如x:Code，x:FieldModifier或x:ClassModifier）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- 现在，该类将在* .g.cs文件中声明为内部类 --&gt;</span>
<span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">&#34;MyWPFApp.MainWindow&#34;</span> <span class="na">x:ClassModifier =</span><span class="s">&#34;internal&#34;</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- This button will be public in the *.g.cs file --&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">x:Name =</span><span class="s">&#34;myButton&#34;</span> <span class="na">x:FieldModifier =</span><span class="s">&#34;public&#34;</span> <span class="na">Content =</span> <span class="s">&#34;OK&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Window&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>默认情况下，所有C＃/ XAML类型定义都是公共的，而成员默认为内部</strong>。但是，根据您的XAML定义，生成的自动生成的文件包含带有公共Button变量的内部类类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">internal</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">,</span>
<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Markup</span><span class="p">.</span><span class="n">IComponentConnector</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">Button</span> <span class="n">myButton</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="xaml元素xaml属性和类型转换器">XAML元素，XAML属性和类型转换器</h4>
<p>建立根元素和所有必需的XML名称空间后，下一个任务是用子元素填充根元素。在实际的WPF应用程序中，子级将是<strong>布局管理器</strong>（例如Grid或StackPanel），该管理器依次包含描述用户界面的任意数量的其他UI元素。下一章将详细研究这些布局管理器，因此现在仅假设您的&lt;Window&gt;类型将包含一个Button元素。</p>
<p>如本章所述，XAML元素映射到给定.NET命名空间中的类或结构类型，而开始元素标记中的属性映射到该类型的属性或事件。为了说明，在Kaxaml中输入以下&lt;Button&gt;定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- Configure the look and feel of a Button --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Background=</span><span class="s">&#34;Green&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，分配给每个属性的值已捕获为简单文本值。这似乎是数据类型的完全不匹配，因为如果要用C＃代码制作此Button，则不会将字符串对象分配给这些属性，而是会使用特定的数据类型。例如，这是代码中编写的同一按钮：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">MakeAButton</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Button</span> <span class="n">myBtn</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Button</span><span class="p">();</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Height</span> <span class="p">=</span> <span class="m">50</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Width</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">FontSize</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="s">&#34;OK!&#34;</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Background</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Green</span><span class="p">);</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Foreground</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Yellow</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>事实证明，WPF附带了许多<strong>类型转换器类</strong>，这些类将用于将简单文本值转换为正确的基础数据类型。此过程透明（自动）进行。</p>
<p>尽管这一切都很好，但是在很多情况下，您需要为XAML属性分配更为复杂的值，而该值不能捕获为简单字符串。例如，假设您要构建自定义画笔来设置Button的Background属性。如果要用代码构建画笔，则非常简单，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">public</span> <span class="k">void</span> <span class="n">MakeAButton</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// A fancy brush for the background.
</span><span class="c1"></span>    <span class="n">LinearGradientBrush</span> <span class="n">fancyBruch</span> <span class="p">=</span> 
        <span class="k">new</span> <span class="n">LinearGradientBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">DarkGreen</span><span class="p">,</span> <span class="n">Colors</span><span class="p">.</span><span class="n">LightGreen</span><span class="p">,</span> <span class="m">45</span><span class="p">);</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Background</span> <span class="p">=</span> <span class="n">fancyBruch</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Foreground</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Yellow</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如何将复杂的画笔表示为字符串？好吧，你不能！值得庆幸的是，XAML提供了一种特殊的语法，该语法在需要将属性值分配给复杂对象时可以使用，称为<strong>属性元素语法</strong>。</p>
<h4 id="了解xaml属性元素语法">了解XAML属性元素语法</h4>
<p>属性元素语法允许您将复杂对象分配给属性。例如这是按钮的XAML描述，该按钮利用LinearGradientBrush设置其Background属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Background&gt;</span>
        <span class="nt">&lt;LinearGradientBrush&gt;</span>
            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">&#34;DarkGreen&#34;</span> <span class="na">Offset=</span><span class="s">&#34;0&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">&#34;LightGreen&#34;</span> <span class="na">Offset=</span><span class="s">&#34;1&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/LinearGradientBrush&gt;</span>
    <span class="nt">&lt;/Button.Background&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，在&lt;Button&gt;和&lt;/Button&gt;标记的范围内，您定义了一个名为&lt;Button.Background&gt;的子范围。在此范围内，您已定义了一个自定义<!-- raw HTML omitted -->。  （不必担心画笔的确切代码；您将在第28章中了解WPF图形）。</p>
<p>一般而言，可以使用property-element语法设置任何属性，该语法始终会分解为以下模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;DefiningClass&gt;</span>
    <span class="nt">&lt;DefiningClass.PropertyOnDefiningClass&gt;</span>
        <span class="c">&lt;!-- Value for Property here! --&gt;</span>
    <span class="nt">&lt;/DefiningClass.PropertyOnDefiningClass&gt;</span>
<span class="nt">&lt;/DefiningClass&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>尽管可以使用此语法设置任何属性，但是如果可以将值捕获为简单字符串，则可以节省键入时间。例如，以下是设置按钮宽度的详细方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Width&gt;</span>
        100
    <span class="nt">&lt;/Button.Width&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="了解xaml附加属性">了解XAML附加属性</h4>
<p>除了属性元素语法外，XAML还定义了一种特殊语法，该语法用于为附加属性设置值。本质上，<strong>附加属性</strong>允许子元素设置在父元素中实际定义的属性的值。遵循的通用模板如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;ParentElement&gt;</span>
    <span class="nt">&lt;ChildElement</span> <span class="na">ParentElement.PropertyOnParent =</span> <span class="s">&#34;Value&#34;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/ParentElement&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>附加属性语法的最常见用法是将UI元素放置在WPF布局管理器类之一（Grid，DockPanel等）中。下一章将详细介绍这些面板。现在，在Kaxaml中输入以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Canvas</span> <span class="na">Height=</span><span class="s">&#34;200&#34;</span> <span class="na">Width=</span><span class="s">&#34;200&#34;</span> <span class="na">Background=</span><span class="s">&#34;LightBlue&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Canvas.Top=</span><span class="s">&#34;40&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;40&#34;</span> <span class="na">Height=</span><span class="s">&#34;20&#34;</span> <span class="na">Width=</span><span class="s">&#34;20&#34;</span> <span class="na">Fill=</span><span class="s">&#34;DarkBlue&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Canvas&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，您定义了一个包含Ellipse的Canvas布局管理器。注意，椭圆能够使用附加的属性语法通知其父级（画布）将其顶部/左侧位置放置在何处。</p>
<h4 id="了解xaml标记扩展">了解XAML标记扩展</h4>
<p>如前所述，属性值通常使用简单的字符串或通过property-element语法表示。但是，还有另一种使用标记扩展来指定XAML属性值的方法。<strong>标记扩展</strong>允许XAML解析器从专用的外部类获取属性的值。鉴于某些属性值需要大量代码语句来执行以找出该值，因此这可能是有益的。</p>
<p><strong>标记扩展</strong>提供了一种通过新功能完全扩展XAML语法的方法。标记扩展在内部表示为从MarkupExtension派生的类。请注意，您需要构建自定义标记扩展的机会微乎其微。但是，XAML关键字的子集（例如x:Array，x:Null，x:Static和x:Type）是伪装的标记扩展！</p>
<p><strong>标记扩展名夹在大括号之间</strong>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Element</span> <span class="na">PropertyToSet =</span> <span class="s">&#34;{MarkUpExtension}&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>要查看实际使用的标记扩展，请将以下内容编写到Kaxaml中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
    <span class="na">xmlns:CorLib=</span><span class="s">&#34;clr-namespace:System;assembly=mscorlib&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="c">&lt;!-- 静态标记扩展使我们可以从类的静态成员获取值 --&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Static CorLib:Environment.OSVersion}&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Static CorLib:Environment.ProcessorCount}&#34;</span><span class="nt">/&gt;</span>

        <span class="c">&lt;!-- 类型标记扩展名是C＃typeof运算符的XAML版本 --&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Type Button}&#34;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Type CorLib:Boolean}&#34;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!-- 用字符串数组填充ListBox！ --&gt;</span>
        <span class="nt">&lt;ListBox</span> <span class="na">Width=</span><span class="s">&#34;200&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;ListBox.ItemsSource&gt;</span>
                <span class="nt">&lt;x:Array</span> <span class="na">Type=</span><span class="s">&#34;CorLib:String&#34;</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Sun Kil Moon<span class="nt">&lt;/CorLib:String&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Red House Painters<span class="nt">&lt;/CorLib:String&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Besnard Lakes<span class="nt">&lt;/CorLib:String&gt;</span>
                <span class="nt">&lt;/x:Array&gt;</span>
            <span class="nt">&lt;/ListBox.ItemsSource&gt;</span>
        <span class="nt">&lt;/ListBox&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，请注意Page定义具有新的XML名称空间声明，该声明使您可以访问mscorlib.dll的System名称空间。 建立此XML名称空间后，您首先要使用x:Static标记扩展名并从System.Environment中的OSVersion和ProcessorCount中获取值。</p>
<p>x:Type标记扩展名使您可以访问指定项目的元数据描述。在这里，您只需分配WPF Button和System.Boolean类型的完全限定名称。</p>
<p>此标记最有趣的部分是ListBox。在这里，您将ItemsSource属性设置为完全在标记中声明的字符串数组！在这里注意x:Array标记扩展如何允许您在其范围内指定一组子项目。</p>
<blockquote>
<p>注意: 前面的XAML示例仅用于说明实际使用的标记扩展。正如您将在第25章中看到的那样，有很多更容易的方法来填充ListBox控件！</p>
</blockquote>
<!-- raw HTML omitted -->
<p>现在，您已经看到了无数示例，这些示例展示了XAML语法的每个核心方面。正如您可能同意的那样，XAML很有趣，因为它允许您以声明的方式描述.NET对象树。尽管这在配置图形用户界面时非常有用，但请记住XAML可以描述任何程序集中的任何类型，只要它是包含默认构造函数的非抽象类型即可。</p>
<h3 id="浏览wpf文档">浏览WPF文档</h3>
<p>在结束本章时，我想指出。.NET4.7 Framework SDK文档提供了专门讨论WPF主题的整个部分。在探索此API并阅读其余以WPF为中心的章节时，如果您尽早并经常咨询帮助系统，将会为您提供出色的服务。在这里，您将找到大量的XAML示例以及有关从3D图形编程到复杂的数据绑定操作的各种主题的详细教程。</p>
<p>您可以通过“文档”➤ .NET➤.NET Framework➤Windows Presentation Foundation菜单访问WPF文档。它位于 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/index">https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/index</a>。</p>
<h3 id="概要">概要</h3>
<p>Windows Presentation Foundation（WPF）是 .NET 3.0发行版中引入的用户界面工具包。WPF的主要目标是将许多以前不相关的桌面技术（2D图形，3D图形，窗口和控件开发等）集成和统一到一个统一的编程模型中。除此之外，WPF程序通常使用XAML，它允许您通过标记声明WPF元素的外观。</p>
<p>回想一下XAML允许您使用声明性语法描述.NET对象的树。在本章对XAML的研究中，您接触到了一些新的语法，包括属性元素语法和附加属性，以及类型转换器和XAML标记扩展的作用。</p>
<p>XAML是任何生产级WPF应用程序的关键方面。本章的最后一个示例使您有机会构建一个WPF应用程序，该应用程序显示了本章讨论的许多概念。下一章将深入探讨这些概念，并介绍更多概念。</p>
<h2 id="wpf控件布局事件和数据绑定">WPF控件，布局，事件和数据绑定</h2>
<p>第24章为WPF编程模型提供了基础，包括检查Window和Application类，XAML语法以及代码文件的使用。第24章还向您介绍了使用Visual Studio设计器构建WPF应用程序的过程。在本章中，您将使用几个新的控件和布局管理器来研究更复杂的图形用户界面的构造，并逐步了解Visual Studio的WPF设计器的其他功能。</p>
<p>本章还将研究一些重要的WPF相关控制主题，例如数据绑定编程模型和控制命令的使用。您还将学习如何使用Ink和Documents API，使用它们可以捕获手写笔（或鼠标）输入并分别使用XML Paper Specification生成RTF文档。</p>
<h3 id="wpf核心控件概述">WPF核心控件概述</h3>
<p>除非您不熟悉构建图形用户界面的概念（这没关系），否则主要WPF控件的一般用途不应引起太多问题。无论您过去使用过哪种GUI工具包（例如，VB 6.0，MFC，Java AWT / Swing，Windows Forms，macOS或GTK+ / GTK＃等），表25-1中列出的WPF核心控件可能看起来都会很熟悉。</p>
<h4 id="wpf-ink-控件">WPF Ink 控件</h4>
<p>除了表25-1中列出的通用WPF控件外，WPF还定义了用于与数字Ink API配合使用的其他控件。WPF开发的这一方面在Tablet PC开发期间非常有用，因为它使您可以从笔中捕获输入。但是，这并不是说标准的桌面应用程序无法利用Ink API，因为相同的控件可以使用鼠标捕获输入。</p>
<p>PresentationCore.dll的System.Windows.Ink命名空间包含各种Ink API支持类型（例如Stroke和StrokeCollection）；但是，大多数Ink API控件（例如InkCanvas和InkPresenter）与通用WPF控件一起打包在PresentationFramework.dll程序集的System.Windows.Controls命名空间下。本章稍后将使用Ink API。</p>
<h4 id="wpf文档控件">WPF文档控件</h4>
<p>WPF还提供了用于高级文档处理的控件，使您可以构建包含Adobe PDF样式功能的应用程序。使用System.Windows.Documents命名空间（同样在PresentationFramework.dll程序集中）中的类型，可以创建支持缩放，搜索，用户注释（便笺）和其他RTF服务的可打印文档。</p>
<p>然而，在幕后，文档控件不使用Adobe PDF API。 而是使用XML Paper Specification（XPS）API。对于最终用户来说，实际上似乎没有什么区别，因为PDF文档和XPS文档具有几乎相同的外观。实际上，您可以找到许多免费的实用程序，使您可以即时在两种文件格式之间进行转换。由于篇幅所限，本版本将不涉及这些控件。</p>
<h4 id="wpf通用对话框">WPF通用对话框</h4>
<p>WPF还为您提供了一些常用对话框，例如OpenFileDialog和SaveFileDialog。这些对话框在PresentationFramework.dll程序集的Microsoft.Win32命名空间中定义。使用这些对话框中的任何一个都需要创建一个对象并调用ShowDialog()方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">Microsoft.Win32</span><span class="p">;</span>
<span class="c1">//omitted for brevity
</span><span class="c1"></span><span class="k">private</span> <span class="k">void</span> <span class="n">btnShowDlg_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Show a file save dialog.
</span><span class="c1"></span>    <span class="n">SaveFileDialog</span> <span class="n">saveDlg</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SaveFileDialog</span><span class="p">();</span>
    <span class="n">saveDlg</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>正如您希望的那样，这些类支持各种成员，这些成员使您可以建立文件过滤器和目录路径，并访问用户选择的文件。您将在以后的示例中使用这些文件对话框。您还将学习如何构建自定义对话框来收集用户输入。</p>
<h3 id="使用面板控制内容布局">使用面板控制内容布局</h3>
<p>您还可以在其他面板（例如，包含其他项目的StackPanel的DockPanel）内混合面板控件，以提供很大的灵活性和控件。表25-2记录了一些常用的WPF面板控件的作用。</p>
<table>
<thead>
<tr>
<th align="center">面板控件</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Canvas</td>
<td align="left">提供经典的内容放置方式。在设计时，物品会完全保留在您放置它们的位置。</td>
</tr>
<tr>
<td align="center">DockPanel</td>
<td align="left">将内容锁定到面板的指定侧（顶部，底部，左侧或右侧）。</td>
</tr>
<tr>
<td align="center">Grid</td>
<td align="left">在表格单元格中维护的一系列单元格中排列内容。</td>
</tr>
<tr>
<td align="center">StackPanel</td>
<td align="left">根据Orientation属性的要求，以垂直或水平方式堆叠内容。</td>
</tr>
<tr>
<td align="center">WrapPanel</td>
<td align="left">将内容从左到右放置，将内容中断到包含框边缘的下一行。 随后的顺序从上到下或从右到左顺序发生，具体取决于Orientation属性的值。</td>
</tr>
</tbody>
</table>
<p>在接下来的几节中，您将通过将一些预定义的XAML数据复制到在第24章中安装的kaxaml.exe应用程序中，学习如何使用这些常用的面板类型。您可以在您的第25章代码下载文件夹PanelMarkup子文件夹中找到所有这些宽松的XAML文件。使用Kaxaml时，要模拟调整窗口的大小，请更改标记中Page元素的高度或宽度。</p>
<h3 id="使用嵌套面板构建窗口框架">使用嵌套面板构建窗口框架</h3>
<h3 id="了解wpf命令">了解WPF命令</h3>
<p>WPF通过命令体系结构为可能被认为与控制无关的事件提供支持。典型的.NET事件是在特定的基类中定义的，并且只能由该类或其派生类使用。因此，普通的.NET事件与定义它们的类紧密相关。</p>
<p>相反，WPF命令是类似事件的实体，独立于特定控件，并且在许多情况下可以成功地应用于多种（看似无关）的控件类型。举几个例子，WPF支持复制，粘贴和剪切命令，您可以将其应用于各种UI元素（例如，菜单项，工具栏按钮和自定义按钮）以及键盘快捷键（例如，Ctrl+C 和 Ctrl+V）。</p>
<p>虽然其他UI工具包（例如Windows Forms）为此目的提供了标准事件，但使用它们通常会给您留下冗余且难以维护的代码。在WPF模型下，您可以使用命令作为替代。最终结果通常会产生更小，更灵活的代码库。</p>
<h3 id="了解路由事件">了解路由事件</h3>
<p>您可能已经注意到上一个代码示例中的RoutedEventArgs参数而不是EventArgs。<strong>路由事件</strong>模型是对标准CLR事件模型的改进，该模型旨在确保可以以适合XAML对对象树的描述的方式来处理事件。假设您有一个名为WPFRoutedEvents的新WPF应用程序项目。现在，通过添加下面的Button控件来更新初始窗口的XAML描述，该按钮定义了一些复杂的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">&#34;btnClickMe&#34;</span> <span class="na">Height=</span><span class="s">&#34;75&#34;</span> <span class="na">Width =</span> <span class="s">&#34;250&#34;</span> <span class="na">Click =</span><span class="s">&#34;btnClickMe_Clicked&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span><span class="nt">&gt;</span>Fancy Button!<span class="nt">&lt;/Label&gt;</span>
        <span class="nt">&lt;Canvas</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;100&#34;</span> <span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span> <span class="na">Height =</span><span class="s">&#34;25&#34;</span>
            <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;innerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Yellow&#34;</span> <span class="na">Height =</span> <span class="s">&#34;15&#34;</span> <span class="na">Width =</span><span class="s">&#34;36&#34;</span>
            <span class="na">Canvas.Top=</span><span class="s">&#34;17&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;32&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Canvas&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，在Button的开头定义中，您已经通过指定引发事件时要调用的方法的名称来处理Click事件。Click事件与RoutedEventHandler委托一起使用，该委托期望一个事件处理程序以一个对象作为第一个参数，并使用System.Windows.RoutedEventArgs作为第二个。如此实现此处理程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">btnClickMe_Clicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Do something when button is clicked.
</span><span class="c1"></span>    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Clicked the button&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果您运行应用程序，则无论您单击按钮内容的哪一部分（绿色的椭圆，黄色的椭圆，标签或按钮的表面），都会看到此消息框显示。这是一件好事。想象一下，如果您被迫为每个子元素处理Click事件，那么WPF事件处理将是多么繁琐。为Button的每个方面创建单独的事件处理程序不仅会很费力，而且您最终还会得到一些强大的令人讨厌的代码来维护。</p>
<p>值得庆幸的是，WPF路由事件可以确保无论自动单击按钮的哪一部分，都将调用单个Click事件处理程序。简而言之，路由事件模型自动在对象树上（或下）传播事件，以寻找合适的处理程序。</p>
<p>具体来说，<strong>路由事件</strong>可以利用三种<strong>路由策略</strong>。如果事件正在从源点移动到对象树中的其他定义范围，则该事件被称为<strong>冒泡事件</strong>。相反，如果事件从最外面的元素（例如，窗口）向下移动到起点，则该事件被称为<strong>隧道事件</strong>。最后，如果仅由始发元素引发和处理事件（可以将其描述为正常CLR事件），则将其称为<strong>直接事件</strong>。</p>
<h4 id="路由冒泡事件的作用">路由冒泡事件的作用</h4>
<p>在当前示例中，如果用户单击内部的黄色椭圆形，则Click事件冒出到下一级作用域（画布），然后到StackPanel，最后到处理Click事件处理程序的Button。以类似的方式，如果用户单击Label，则事件将冒泡到StackPanel，然后最终冒泡到Button元素。</p>
<p>有了这种冒泡的路由事件模式，您就不必担心为复合控件的所有成员注册特定的Click事件处理程序。但是，如果要对同一对象树中的多个元素执行自定义单击逻辑，则可以执行此操作。</p>
<p>举例说明，假设您需要以独特的方式处理externalEllipse控件的单击。首先，处理此子元素的MouseDown事件（图形呈现的类型，例如Ellipse不支持Click事件；但是，它们可以通过MouseDown，MouseUp等监视鼠标按钮的活动）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">&#34;btnClickMe&#34;</span> <span class="na">Height=</span><span class="s">&#34;75&#34;</span> <span class="na">Width =</span> <span class="s">&#34;250&#34;</span> <span class="na">Click =</span><span class="s">&#34;btnClickMe_Clicked&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span><span class="nt">&gt;</span>Fancy Button!<span class="nt">&lt;/Label&gt;</span>
        <span class="nt">&lt;Canvas</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;100&#34;</span> <span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span>
            <span class="na">Height =</span><span class="s">&#34;25&#34;</span> <span class="na">MouseDown =</span><span class="s">&#34;outerEllipse_MouseDown&#34;</span>
            <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;innerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Yellow&#34;</span> <span class="na">Height =</span> <span class="s">&#34;15&#34;</span> <span class="na">Width =</span><span class="s">&#34;36&#34;</span>
            <span class="na">Canvas.Top=</span><span class="s">&#34;17&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;32&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Canvas&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>然后实现一个适当的事件处理程序，出于说明目的，该事件处理程序将仅更改主窗口的Title属性，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change title of window.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">Title</span> <span class="p">=</span> <span class="s">&#34;You clicked the outer ellipse!&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，您现在可以根据最终用户单击的位置（归结为外部椭圆以及按钮范围内的所有其他位置）采取不同的操作方式。</p>
<blockquote>
<p>注意: 路由冒泡事件始终从原点移动到下一个定义范围。因此，在此示例中，如果单击innerEllipse对象，则事件将冒泡到Canvas，而不是到externalEllipse，因为它们都是Canvas范围内的Ellipse类型。</p>
</blockquote>
<h4 id="继续或停止冒泡">继续或停止冒泡</h4>
<p>当前，如果用户单击outerEllipse对象，它将触发为此Ellipse对象注册的MouseDown事件处理程序，此时该事件会冒泡到按钮的Click事件。如果要通知WPF停止冒泡对象树，可以将EventArgs参数的Handled属性设置为true，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change title of window.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">Title</span> <span class="p">=</span> <span class="s">&#34;You clicked the outer ellipse!&#34;</span><span class="p">;</span>
    <span class="c1">// Stop bubbling!
</span><span class="c1"></span>    <span class="n">e</span><span class="p">.</span><span class="n">Handled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种情况下，您会发现窗口的标题已更改，但是您将看不到Button的Click事件处理程序显示的MessageBox。 简而言之，路由冒泡事件可以使一组复杂的内容充当单个逻辑元素（例如Button）或离散项（例如Button中的Ellipse）。</p>
<h4 id="路由隧道事件的作用">路由隧道事件的作用</h4>
<p>严格来说，路由事件实际上可以是冒泡的（如刚刚描述的）或隧穿的 隧道事件（所有事件均以Preview后缀开头-例如PreviewMouseDown）从最顶层的元素向下钻入对象树的内部范围。总的来说，WPF基类库中的每个冒泡事件都与一个相关的隧道事件配对，该事件在冒泡对象之前触发。例如，在启动冒泡的MouseDown事件之前，将先触发隧道化PreviewMouseDown事件。</p>
<p>处理隧道事件看起来就像处理其他任何事件一样。只需在XAML中分配事件处理程序名称即可（或者，如果需要，在代码文件中使用相应的C＃事件处理语法），然后在代码文件中实现处理程序。只是为了说明隧道事件和冒泡事件之间的相互作用，首先要处理externalEllipse对象的PreviewMouseDown事件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span> <span class="na">Height =</span><span class="s">&#34;25&#34;</span>
        <span class="na">MouseDown =</span><span class="s">&#34;outerEllipse_MouseDown&#34;</span>
        <span class="na">PreviewMouseDown =</span><span class="s">&#34;outerEllipse_PreviewMouseDown&#34;</span>
        <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来，通过使用传入事件args对象更新每个事件处理程序（针对所有对象）以更新当前C＃类定义，以将有关当前事件的数据附加到名为mouseActivity的字符串成员变量中。这将使您观察后台触发的事件流。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">_mouseActivity</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">InitializeComponent</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="n">btnClickMe_Clicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">_mouseActivity</span><span class="p">,</span> <span class="s">&#34;Your Event Info&#34;</span><span class="p">);</span>
        <span class="c1">// Clear string for next round.
</span><span class="c1"></span>        <span class="n">_mouseActivity</span> <span class="p">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">AddEventInfo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_mouseActivity</span> <span class="p">+=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span>
            <span class="s">&#34;{0} sent a {1} event named {2}.\n&#34;</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">RoutedEvent</span><span class="p">.</span><span class="n">RoutingStrategy</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">RoutedEvent</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">outerEllipse_PreviewMouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，您不会停止任何事件处理程序的事件冒泡。如果运行此应用程序，则将根据单击按钮的位置显示唯一的消息框。图25-15显示了单击外部Ellipse对象的结果。</p>
<!-- raw HTML omitted -->
<p>那么，为什么WPF事件通常倾向于成对出现（一个隧道和一个冒泡）？ 答案是，通过预览事件，您可以在启动冒泡对象之前执行任何特殊的逻辑（数据验证，禁用冒泡操作等）。举例来说，假设您有一个TextBox，它只应包含数字数据。您可以处理PreviewKeyDown事件，并且如果看到用户输入了非数字数据，则可以通过将Handled属性设置为true来取消冒泡事件。</p>
<p>就像您猜到的那样，当您构建包含自定义事件的自定义控件时，您可以通过以下方式创作事件：事件可以在XAML树中冒泡（或隧穿）。就本章而言，我不会研究如何构建自定义路由事件（但是，该过程与构建自定义依赖项属性没有什么不同）。如果您有兴趣，请查看.NET Framework 4.7 SDK文档中的“路由事件概述”主题。 在其中，您会找到许多可以帮助您的教程。</p>
<h3 id="深入了解wpf-api和控件">深入了解WPF API和控件</h3>
<p>本章的其余部分将使您有机会使用Visual Studio构建新的WPF应用程序。目标是创建一个由包含一组选项卡的TabControl小部件组成的UI。每个选项卡将说明您可能希望在软件项目中使用的一些新的WPF控件和有趣的API。在此过程中，您还将学习Visual Studio WPF设计器的其他功能。</p>
<h4 id="使用tabcontrol">使用TabControl</h4>
<p>首先，创建一个名为WpfControlsAndAPIs的新WPF应用程序。如前所述，您的初始窗口将包含一个带有三个不同选项卡的TabControl，每个选项卡都展示了一组相关的控件和/或WPF API。 将窗口的宽度更新为800，高度更新为350。</p>
<h3 id="概要-1">概要</h3>
<p>本章从控件工具包的概述和布局管理器（面板）的作用开始，研究了WPF控件的几个方面。第一个示例使您有机会构建一个简单的文字处理器应用程序，该应用程序说明了WPF的集成拼写检查功能，以及如何构建具有菜单系统，状态栏和工具栏的主窗口。</p>
<p>更重要的是，您研究了如何使用WPF命令。回想一下，您可以将这些不可知的事件附加到UI元素或输入手势，以自动继承现成的服务（例如剪贴板操作）。</p>
<p>您还学到了很多有关在XAML中构建复杂UI的知识，并且同时了解了WPF Ink API。您还收到了WPF数据绑定操作的介绍，包括如何使用WPF DataGrid类显示自定义AutoLot数据库中的数据。</p>
<p>最后，您研究了WPF如何对传统.NET编程原语（特别是属性和事件）施加独特的影响。如您所见，依赖项属性使您可以构建可以集成到WPF服务集（动画，数据绑定，样式等）中的属性。与此相关的是，路由事件为事件提供了一种在标记树上向上或向下流动的方式。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Single Long</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-12-03
      
        <a href="https://github.com/SLKyrim/myBlog/commit/6525e595026bee59c66248ec5b6d298ff9777d6e" title="Draft (#1)">
          (6525e59)
        </a>
        
          <br>Draft (#1)
        
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://slkyrim.github.io/tags/c#/">C#</a>
          <a href="https://slkyrim.github.io/tags/wpf/">WPF</a>
          <a href="https://slkyrim.github.io/tags/copytranslator/">CopyTranslator</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/note_csharp_call_c_dll/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">WPF应用程序调用C编译生成的DLL动态链接库</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/book_reinforcement_learning/">
            <span class="next-text nav-default">《强化学习》(第2版)读书笔记</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "SLKyrim/comments-for-myBlog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:623962644@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/SLKyrim" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://slkyrim.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Single Long
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>

<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>《精通 C# 7》(2017版)阅读记录 - Single Long</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Single Long" />
  <meta name="description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应" />

  <meta name="keywords" content="Single Long, Blog" />






<meta name="generator" content="Hugo 0.74.3" />


<link rel="canonical" href="https://slkyrim.github.io/post/book_pro_csharp_7/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="《精通 C# 7》(2017版)阅读记录" />
<meta property="og:description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://slkyrim.github.io/post/book_pro_csharp_7/" />
<meta property="article:published_time" content="2020-12-02T11:00:41+08:00" />
<meta property="article:modified_time" content="2020-12-03T20:23:40+08:00" />
<meta itemprop="name" content="《精通 C# 7》(2017版)阅读记录">
<meta itemprop="description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应">
<meta itemprop="datePublished" content="2020-12-02T11:00:41+08:00" />
<meta itemprop="dateModified" content="2020-12-03T20:23:40+08:00" />
<meta itemprop="wordCount" content="28246">



<meta itemprop="keywords" content="C#,WPF,CopyTranslator," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《精通 C# 7》(2017版)阅读记录"/>
<meta name="twitter:description" content="Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al. 第VII部分 Windows Presentation Foundation 第24章 Windows Presentation Foundation和XAML简介 当.NET平台的1.0版发布时，需要构建图形桌面应"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">龍</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      龍
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://slkyrim.github.io/about/">关于</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">《精通 C# 7》(2017版)阅读记录</h1>
      
      <div class="post-meta">
        <time datetime="2020-12-02" class="post-time">
          2020-12-02
        </time>
        <div class="post-category">
            <a href="https://slkyrim.github.io/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/"> 技术书籍 </a>
            
          </div>
        <span class="more-meta"> 约 28246 字 </span>
          <span class="more-meta"> 预计阅读 57 分钟 </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第vii部分-windows-presentation-foundation">第VII部分 Windows Presentation Foundation</a>
      <ul>
        <li><a href="#第24章-windows-presentation-foundation和xaml简介">第24章 Windows Presentation Foundation和XAML简介</a></li>
        <li><a href="#研究wpf程序集">研究WPF程序集</a></li>
        <li><a href="#了解wpf-xaml的语法">了解WPF XAML的语法</a></li>
        <li><a href="#浏览wpf文档">浏览WPF文档</a></li>
        <li><a href="#概要">概要</a></li>
      </ul>
    </li>
    <li><a href="#第25章-wpf控件布局事件和数据绑定">第25章 WPF控件，布局，事件和数据绑定</a>
      <ul>
        <li><a href="#wpf核心控件概述">WPF核心控件概述</a></li>
        <li><a href="#使用面板控制内容布局">使用面板控制内容布局</a></li>
        <li><a href="#使用嵌套面板构建窗口框架">使用嵌套面板构建窗口框架</a></li>
        <li><a href="#了解wpf命令">了解WPF命令</a></li>
        <li><a href="#了解路由事件">了解路由事件</a></li>
        <li><a href="#深入了解wpf-api和控件">深入了解WPF API和控件</a></li>
        <li><a href="#构建ink-api标签">构建Ink API标签</a></li>
        <li><a href="#介绍wpf数据绑定模型">介绍WPF数据绑定模型</a></li>
        <li><a href="#了解依赖属性的作用">了解依赖属性的作用</a></li>
        <li><a href="#概要-1">概要</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="pro-c-7-with-net-and-net-core---andrew-troelsen-et-al">Pro C# 7 with .NET and .NET Core - Andrew Troelsen et al.</h1>
<h2 id="第vii部分-windows-presentation-foundation">第VII部分 Windows Presentation Foundation</h2>
<h3 id="第24章-windows-presentation-foundation和xaml简介">第24章 Windows Presentation Foundation和XAML简介</h3>
<p>当.NET平台的1.0版发布时，需要构建图形桌面应用程序的程序员使用了两个API，它们分别名为Windows Forms和GDI+，这些API主要打包在System.Windows.Forms.dll和System.Drawing.dll程序集。尽管Windows Forms / GDI+仍然是用于构建传统桌面GUI的可行API，但是Microsoft从.NET 3.0版本开始提供了另一种名为Windows Presentation Foundation（WPF）的GUI桌面API。</p>
<p>WPF最初的这一章首先探讨了这个新GUI框架背后的动机，这将帮助您了解Windows Forms / GDI+和WPF编程模型之间的区别。接下来，您将了解几个重要类的角色，包括Application，Window，ContentControl，Control，UIElement和FrameworkElement。</p>
<p>然后，本章将向您介绍名为Extensible Application Markup Language（XAML；发音为“ zammel”）的基于XML的语法。在这里，您将学习XAML的语法和语义（包括附加的属性语法以及类型转换器和标记扩展的作用）</p>
<p>本章最后通过构建第一个WPF应用程序来研究Visual Studio的集成WPF设计器。在这段时间里，您将学习如何拦截键盘和鼠标活动，定义应用程序范围的数据以及执行其他常见的WPF任务。</p>
<h4 id="wpf背后的动机">WPF背后的动机</h4>
<p>多年来，Microsoft创建了许多图形用户界面工具包（原始C/C++/Windows API开发，VB6，MFC等）来构建桌面可执行文件。 这些API均提供了一个代码库来表示GUI应用程序的基本方面，包括主窗口，对话框，控件，菜单系统和其他基本必需品。 随着.NET平台的最初发行，Windows Forms API凭借其简单而强大的对象模型迅速成为UI开发的首选模型。</p>
<p>尽管已经使用Windows Forms成功创建了许多功能齐全的桌面应用程序，但事实是该编程模型相当不对称。简而言之，System.Windows.Forms.dll和System.Drawing.dll不为构建功能丰富的桌面应用程序所需的许多其他技术提供直接支持。为了说明这一点，请考虑WPF发行之前的GUI桌面开发的特殊性质（请参阅表24-1）。</p>
<p>如您所见，Windows Forms开发人员必须从许多不相关的API和对象模型中提取类型。虽然在语法上看起来确实可以使用这些不同的API（毕竟只是C＃代码），但是您可能还同意每种技术都需要完全不同的思维方式。例如，使用DirectX创建3D渲染动画所需的技能与用于将数据绑定到网格的技能完全不同。可以肯定的是，Windows Forms程序员很难掌握每个API的多样性。</p>
<h4 id="统一各种api">统一各种API</h4>
<p>创建WPF的目的是将这些以前不相关的编程任务合并到一个统一的对象模型中。因此，如果您需要编写3D动画，则无需针对DirectX API进行手动编程（尽管可以），因为3D功能直接包含在WPF中。若要查看清理情况，请考虑表24-2，该表说明了从.NET 3.0开始引入的桌面开发模型。</p>
<p>显而易见的好处是，.NET程序员现在拥有一个对称的API，可以满足所有常见的GUI桌面编程需求。当您对主要的WPF程序集的功能和XAML的语法感到满意之后，您会惊讶地发现创建复杂UI的速度如此之快。</p>
<h4 id="通过xaml提供关注点分离">通过XAML提供关注点分离</h4>
<p>也许最引人注目的好处之一是WPF提供了一种将GUI应用程序的外观与驱动它的编程逻辑完全分开的方法。使用XAML，可以通过XML标记定义应用程序的UI。然后可以将此标记（最好使用Microsoft Visual Studio或Microsoft Expression Blend等工具生成）连接到相关的C＃代码文件，以提供程序的实质功能。</p>
<blockquote>
<p>注意: XAML不限于WPF应用程序。任何应用程序都可以使用XAML来描述.NET对象树，即使它们与可见的用户界面无关。</p>
</blockquote>
<p>在研究WPF时，您可能会惊讶于此“桌面标记”提供的灵活性。XAML不仅使您可以在标记中定义简单的UI元素（按钮，网格，列表框等），而且还可以定义交互式2D和3D图形，动画，数据绑定逻辑以及多媒体功能（例如视频播放）。</p>
<p>XAML还使自定义控件如何呈现其视觉外观变得容易。例如，定义使公司徽标具有动画效果的圆形按钮控件仅需要几行标记。如第27章所示，可以通过样式和模板来修改WPF控件，使您能够以最小的麻烦和麻烦来更改应用程序的整体外观。 与Windows Forms开发不同，从头开始构建自定义WPF控件的唯一令人信服的理由是，如果您需要更改控件的行为（例如，添加自定义方法，属性或事件；子类化现有控件以覆盖虚拟成员）。如果您只需要更改控件的外观（例如，圆形动画按钮），则可以完全通过标记进行更改。</p>
<h4 id="提供优化的渲染模型">提供优化的渲染模型</h4>
<p>GUI工具包（例如Windows Forms，MFC或VB6）使用基于C的低级API（GDI）来执行所有图形渲染请求（包括UI元素（如按钮和列表框）的渲染）。 Windows操作系统已有多年历史。GDI为典型的业务应用程序或简单的图形程序提供了足够的性能；但是，如果需要UI应用程序来利用高性能图形，则需要DirectX。</p>
<p>WPF编程模型的不同之处在于，呈现图形数据时不使用GDI。现在，所有渲染操作（例如2D图形，3D图形，动画，控件渲染等）都使用DirectX API。第一个明显的好处是您的WPF应用程序将自动利用硬件和软件优化。 同样，WPF应用程序可以利用非常丰富的图形服务（模糊效果，抗锯齿，透明度等），而无需直接针对DirectX API进行编程的复杂性。</p>
<blockquote>
<p>注意: 尽管WPF确实将所有渲染请求都推送到DirectX层，但我不想建议WPF应用程序的执行速度与直接使用非托管C++和DirectX构建应用程序的速度一样快。尽管.NET 4.7中的WPF已经取得了显着进步，但是如果您打算构建需要最快执行速度的桌面应用程序（例如3D视频游戏），则非托管C++和DirectX仍然是最好的方法。</p>
</blockquote>
<h4 id="简化复杂的ui编程">简化复杂的UI编程</h4>
<p>到目前为止，总而言之，Windows Presentation Foundation（WPF）是用于构建桌面应用程序的API，该API将各种桌面API集成到单个对象模型中，并通过XAML清晰地分离了关注点。除了这些要点之外，WPF应用程序还受益于一种将服务集成到程序中的简单方法，这在过去一直很复杂。以下是WPF核心功能的简要介绍：</p>
<ul>
<li>许多布局管理器（远远超过Windows窗体）提供了对内容放置和重新放置的极其灵活的控制。</li>
<li>使用增强的数据绑定引擎以多种方式将内容绑定到UI元素。</li>
<li>内置样式引擎，使您可以为WPF应用程序定义“主题”。</li>
<li>使用矢量图形，可以自动调整内容大小以适合承载应用程序的屏幕的大小和分辨率。</li>
<li>支持2D和3D图形，动画以及视频和音频播放。</li>
<li>丰富的排版API，例如对XML Paper Specification（XPS）文档，固定文档（WYSIWYG），流程文档和文档注释的支持（例如，Sticky Notes API）。</li>
<li>支持与旧版GUI模型（例如Windows Forms，ActiveX和Win32 HWND）进行互操作。例如，您可以将自定义Windows Forms控件合并到WPF应用程序中，反之亦然。</li>
</ul>
<p>现在，您已经了解了WPF的功能，让我们看一下可以使用此API创建的各种类型的应用程序。 这些功能中的许多功能将在以后的章节中详细探讨。</p>
<h3 id="研究wpf程序集">研究WPF程序集</h3>
<p>WPF最终不过是.NET程序集中捆绑在一起的类型的集合而已。表24-3描述了用于构建WPF应用程序的关键程序集，在创建新项目时必须引用每个程序集。如您所愿，Visual Studio WPF项目会自动引用这些必需的程序集。</p>
<p>表24-3中这四个程序集共同定义了许多新的名称空间以及数百种新的.NET类，接口，结构，枚举和委托。 尽管应该查阅.NET Framework 4.7 SDK文档以获取完整的详细信息，但表24-4描述了一些（但不是全部）重要名称空间的作用。</p>
<p>为了开始使用WPF编程模型，您将检查System.Windows命名空间的两个成员：Application和Window，它们是任何传统桌面开发工作中常见的。</p>
<blockquote>
<p>注意：如果使用Windows Forms API创建了桌面UI，请注意System.Windows.Forms.* 和System.Drawing.*程序集与WPF不相关。这些库代表原始的.NET GUI工具包Windows Forms / GDI+。</p>
</blockquote>
<h4 id="application类的作用">Application类的作用</h4>
<p>System.Windows.Application类表示正在运行的WPF应用程序的全局实例。此类提供了Run()方法（用于启动应用程序），一系列事件，您可以处理这些事件以与应用程序的生命周期进行交互（例如Startup和Exit），以及一些特定于XAML浏览器应用程序（例如，当用户在页面之间导航时触发的事件）。 表24-5详细列出了一些关键属性。</p>
<h4 id="构造application类">构造Application类</h4>
<p>任何WPF应用程序都需要定义一个扩展Application的类。 在此类中，您将定义程序的入口点（Main（）方法），该入口点创建此子类的实例，并通常处理Startup和Exit事件（必要时）。 这是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="c1">// Define the global application object for this WPF program.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">MyApp</span> <span class="p">:</span> <span class="n">Application</span>
<span class="p">{</span>
<span class="na">    [STAThread]</span>
    <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Create the application object.
</span><span class="c1"></span>        <span class="n">MyApp</span> <span class="n">app</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyApp</span><span class="p">();</span>
        <span class="c1">// Register the Startup/Exit events.
</span><span class="c1"></span>        <span class="n">app</span><span class="p">.</span><span class="n">Startup</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* Start up the app */</span> <span class="p">};</span>
        <span class="n">app</span><span class="p">.</span><span class="n">Exit</span> <span class="p">+=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* Exit the app */</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在启动处理程序中，您通常会处理所有传入的命令行参数并启动程序的主窗口。如您所料，可以在Exit处理程序中编写该程序的任何必要关闭逻辑（例如，保存用户首选项，写入Windows注册表）。</p>
<blockquote>
<p>注意: WPF应用程序的Main（）方法必须具有[STAThread]属性，该属性可确保您的应用程序使用的所有旧COM对象都是线程安全的。如果不以这种方式注释Main（），则会遇到运行时异常。</p>
</blockquote>
<h4 id="枚举windows集合">枚举Windows集合</h4>
<p>应用程序公开的另一个有趣的属性是Windows，它提供对表示当前WPF应用程序加载到内存中的每个窗口的集合的访问。回想一下，当您创建新的Window对象时，它们会自动添加到Application.Windows集合中。这是一个示例方法，该方法将最小化应用程序的每个窗口（可能响应最终用户触发的给定键盘手势或菜单选项）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="c1">// Define the global application object for this WPF program.
</span><span class="c1"></span><span class="k">static</span> <span class="k">void</span> <span class="n">MinimizeAllWindows</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">Window</span> <span class="n">wnd</span> <span class="k">in</span> <span class="n">Application</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Windows</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">wnd</span><span class="p">.</span><span class="n">WindowState</span> <span class="p">=</span> <span class="n">WindowState</span><span class="p">.</span><span class="n">Minimized</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>您将很快构建一些WPF应用程序，但是在此之前，让我们检查一下Window类型的核心功能，并在此过程中了解许多重要的WPF基类。</p>
<h4 id="窗口类的作用">窗口类的作用</h4>
<p>System.Windows.Window类（位于PresentationFramework.dll程序集中）表示由Application派生的类拥有的单个窗口，包括主窗口显示的所有对话框。毫不奇怪，Window有一系列父类，每个父类都为表带来了更多功能。请考虑图24-1，该图显示了通过Visual Studio对象浏览器看到的System.Windows.Window的继承链（和实现的接口）。</p>
<!-- raw HTML omitted -->
<p>在学习本章及以后的各章时，您将了解这些基本类提供的功能。但是，为激起您的胃口，以下各节提供了每个基类提供的功能的细分（有关详细信息，请查阅.NET Framework 4.7 SDK文档）。</p>
<h4 id="systemwindowscontrolscontentcontrol的角色">System.Windows.Controls.ContentControl的角色</h4>
<p>Window的直接父级是ContentControl，它很可能是所有WPF类中最诱人的。此基类为派生类型提供了承载单个内容的能力，简单地说，就是通过Content属性引用放置在控件表面区域内部的可视数据。WPF内容模型使自定义内容控件的基本外观非常简单。</p>
<p>例如，当您想到典型的“按钮”控件时，您倾向于假定内容是简单的字符串文字（“确定”，“取消”，“中止”等）。 如果您使用XAML来描述WPF控件，并且想要分配给Content属性的值可以作为一个简单的字符串捕获，则可以在元素的开头定义内设置Content属性（不要担心确切的含义）。 标记）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Setting the Content value in the opening element --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：Content属性也可以用C＃代码设置，这使您可以在运行时更改控件的内部。</p>
</blockquote>
<p>但是，内容几乎可以是任何东西。例如，假设您想要一个“按钮”，其功能比简单的字符串（也许是自定义图形和文本模糊）更有趣。在其他UI框架（例如Windows Forms）中，将要求您构建自定义控件，这可能需要大量代码并需要维护一个全新的类。使用WPF内容模型，无需这样做。</p>
<p>如果您想将Content属性分配给无法以简单字符数组捕获的值，则无法使用控件的开始定义中的属性来分配它。相反，您必须在元素范围内隐式定义内容数据。 例如，以下 &lt;Button&gt; 包含 &lt;StackPanel&gt; 作为内容，其本身包含一些唯一的数据（准确地说是&lt;Ellipse&gt;和&lt;Label&gt;）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Implicitly setting the Content property with complex data --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Red&#34;</span> <span class="na">Width=</span><span class="s">&#34;25&#34;</span> <span class="na">Height=</span><span class="s">&#34;25&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;OK!&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>您还可以使用XAML的属性元素语法来设置复杂的内容。考虑下面的功能上等效的&lt;Button&gt;定义，该定义使用property-element语法显式设置了Content属性（同样，您将在本章后面找到有关XAML的更多信息，因此，请不要花太多时间在细节上）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Setting the Content property using property-element syntax --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;80&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Content&gt;</span>
        <span class="nt">&lt;StackPanel&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Red&#34;</span> <span class="na">Width=</span><span class="s">&#34;25&#34;</span> <span class="na">Height=</span><span class="s">&#34;25&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;OK!&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
    <span class="nt">&lt;/Button.Content&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，并非每个WPF元素都派生自ContentControl，因此，并非所有控件都支持此唯一的内容模型（但是，大多数控件都支持）。同样，某些WPF控件对您刚刚检查过的基本内容模型进行了一些改进。第25章将更详细地研究WPF内容的作用。</p>
<h4 id="systemwindowscontrolscontrol的角色">System.Windows.Controls.Control的角色</h4>
<p>与ContentControl不同，所有WPF控件均作为通用父级共享Control基类。该基类提供了许多基本的UI功能核心成员。例如，控件定义属性以建立控件的大小，不透明度，标签顺序逻辑，显示光标，背景颜色等。此外，此父类为模板服务提供支持。如第27章所述，WPF控件可以使用模板和样式完全改变其呈现外观的方式。表24-6列出了Control类型的一些关键成员，按相关功能分组。</p>
<h4 id="systemwindowsframeworkelement的角色">System.Windows.FrameworkElement的角色</h4>
<p>此基类提供了许多在WPF框架中使用的成员，例如对情节提要（在动画中使用）的支持和对<strong>数据绑定</strong>的支持，以及（通过Name属性）命名成员的能力，以获得任何由派生类型定义的资源，并建立派生类型的整体尺寸。表24-7列出了重点内容。</p>
<h4 id="systemwindowsuielement的角色">System.Windows.UIElement的角色</h4>
<p>在Window的继承链中的所有类型中，UIElement基类提供了最多的功能。UIElement的关键任务是为派生类型提供大量事件，以允许派生类型接收焦点并处理输入请求。例如，此类提供大量事件来说明拖放操作，鼠标移动，键盘输入和手写笔输入（适用于Pocket PC和Tablet PC）。</p>
<p>第25章详细探讨了WPF事件模型。但是，许多核心事件看起来都很熟悉（MouseMove，KeyUp，MouseDown，MouseEnter，MouseLeave等）。除了定义数十个事件外，该父类还提供了许多属性来说明控件焦点，启用状态，可见性和命中测试逻辑，如表24-8所示。</p>
<h4 id="systemwindowsthreadingdispatcherobject的角色">System.Windows.Threading.DispatcherObject的角色</h4>
<p>Window类型的最后一个基类（超出System.Object，我认为在书中此刻不需要进一步说明）是DispatcherObject。此类型提供一个有用的属性Dispatcher，该属性返回关联的System.Windows.Threading.Dispatcher对象。<strong>Dispatcher类是WPF应用程序事件队列的入口点，它提供了处理并发和线程的基本构造</strong>。</p>
<h3 id="了解wpf-xaml的语法">了解WPF XAML的语法</h3>
<p>生产级WPF应用程序通常将使用专用工具来生成必要的XAML。尽管这些工具很有用，但了解XAML标记的整体结构是一个好主意。为了帮助您进行学习，请允许我介绍一种流行的（免费的）工具，该工具可让您轻松地尝试XAML。</p>
<h4 id="介绍kaxaml">介绍Kaxaml</h4>
<p>当您第一次学习XAML语法时，使用名为Kaxaml的免费工具会有所帮助。您可以从可下载文件中的Kaxaml目录中获得此流行的XAML编辑器/解析器。</p>
<blockquote>
<p>注意：对于本书的许多版本，我都已将用户指向 <a href="http://www.kaxaml.com">www.kaxaml.com</a>，但不幸的是，该站点已淘汰。我在本书的可下载材料中拥有.msi软件包的副本，并且还将存储库分叉到了我的个人GitHub帐户（www.github.com/skimedic/kaxaml ），以确保它可以继续使用。非常感谢并感谢Kaxaml的开发人员；这是一个很棒的工具，已帮助无数开发人员学习XAML。</p>
</blockquote>
<p>Kaxaml很有帮助，因为它不了解C＃源代码，事件处理程序或实现逻辑。与使用成熟的Visual Studio WPF项目模板相比，它是测试XAML代码片段的直接得多的方法。同样，Kaxaml具有许多集成工具，例如颜色选择器，XAML代码段管理器，甚至是“XAML清理程序”选项，这些选项都将根据您的设置来格式化XAML。首次打开Kaxaml时，将为Page控件找到简单的标记，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>

    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>类似于Window，Page包含各种布局管理器和控件。但是，与Window不同，Page对象不能作为独立实体运行。 而是必须将它们放置在合适的主机内，例如NavigationWindow或Frame。好消息是您可以在Page或Window范围内键入相同的标记。</p>
<p>作为初始测试，请在工具底部的XAML窗格中输入以下标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- A button with custom content --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;100&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Green&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，您应该在Kaxaml编辑器的上部看到页面渲染（参见图24-2）。</p>
<!-- raw HTML omitted -->
<p>当您使用Kaxaml时，请记住，该工具不允许您编写任何需要代码编译的标记（但是，允许使用x：Name）。 这包括定义x：Class属性（用于指定代码文件），在标记中输入事件处理程序名称，或使用也需要进行代码编译的任何XAML关键字（例如FieldModifier或ClassModifier）。任何尝试这样做都会导致标记错误。</p>
<h4 id="xaml-xml命名空间和xaml关键字">XAML XML命名空间和XAML“关键字”</h4>
<p>WPF XAML文档的根元素（例如Window，Page，UserControl或Application定义）几乎总是引用以下两个预定义的XML名称空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
    
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>第一个XML名称空间: <a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation">http://schemas.microsoft.com/winfx/2006/xaml/presentation</a> 映射了一系列WPF .NET名称空间（System.Windows，System.Windows.Controls，System.Windows.Data，System.Windows.Ink，System.Windows.Media等），提供给当前的 *.xaml文件。</p>
<p>实际上，此一对多映射是使用程序集级[XmlnsDefinition]属性在WPF程序集（WindowsBase.dll，PresentationCore.dll和PresentationFramework.dll）中进行硬编码的。例如，如果打开Visual Studio对象浏览器并选择PresentationCore.dll程序集，您将看到诸如以下的清单，这些清单实际上导入了System.Windows：</p>
<blockquote>
<p>[assembly: XmlnsDefinition(&ldquo;http://schemas.microsoft.com/winfx/2006/xaml/presentation&rdquo;,
&ldquo;System.Windows&rdquo;)]</p>
</blockquote>
<p>第二个XML名称空间 <a href="http://schemas.microsoft.com/winfx/2006/xaml">http://schemas.microsoft.com/winfx/2006/xaml</a> ，用于包括XAML专用的“关键字”（由于缺乏更好的用语），以及包含System.Windows.Markup名称空间，如下所示：</p>
<blockquote>
<p>[assembly: XmlnsDefinition(&ldquo;http://schemas.microsoft.com/winfx/2006/xaml&rdquo;,
&ldquo;System.Windows.Markup&rdquo;)]</p>
</blockquote>
<p>任何格式正确的XML文档（请记住，XAML是基于XML的语法）的一个规则是，开头的根元素将一个XML名称空间指定为主名称空间，该名称空间通常是包含最常用项目的名称空间。如果根元素要求包含其他辅助名称空间（如此处所示），则必须使用唯一的标记前缀定义它们（以解决任何可能的名称冲突）。按照惯例，前缀只是x；但是，这可以是您需要的任何唯一令牌，例如XamlSpecificStuff。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:XamlSpecificStuff=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- A button with custom content --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">XamlSpecificStuff:Name=</span><span class="s">&#34;button1&#34;</span> <span class="na">Height=</span><span class="s">&#34;100&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&#34;Green&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Button&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>定义冗长的XML名称空间前缀的明显缺点是，每次您的XAML文件需要引用此XML名称空间中定义的项之一时，都需要键入XamlSpecificStuff。鉴于XamlSpecificStuff需要许多其他的击键，只要坚持使用x替代即可。</p>
<p>无论如何，除了x:Name，x:Class和x:Code关键字之外，http//schemas.microsoft.com/winfx/2006/xaml XML命名空间还提供对其他XAML关键字（最常见的XAML关键字）的访问权限 如表24-9所示。</p>
<table>
<thead>
<tr>
<th align="center">XAML关键字</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">x:Array</td>
<td align="left">表示XAML中的.NET数组类型</td>
</tr>
<tr>
<td align="center">x:ClassModifier</td>
<td align="left">允许您定义由Class关键字表示的C＃类（内部或公共）的可见性。</td>
</tr>
<tr>
<td align="center">x:FieldModifier</td>
<td align="left">允许您为根的任何命名子元素（例如，Window元素中的Button）定义类型成员（内部，公共，私有或受保护）的可见性。 使用Name XAML关键字定义命名元素。</td>
</tr>
<tr>
<td align="center">x:Key</td>
<td align="left">允许您为XAML项目建立键值，该键值将放入字典元素中。</td>
</tr>
<tr>
<td align="center">x:Name</td>
<td align="left">允许您指定给定XAML元素的生成的C＃名称</td>
</tr>
<tr>
<td align="center">x:Null</td>
<td align="left">表示空引用</td>
</tr>
<tr>
<td align="center">x:Static</td>
<td align="left">允许您引用类型的静态成员</td>
</tr>
<tr>
<td align="center">x:Type</td>
<td align="left">等效于C＃typeof运算符的XAML（它将根据提供的名称生成System.Type）</td>
</tr>
<tr>
<td align="center">x:TypeArguments</td>
<td align="left">允许您将元素建立为具有特定类型参数的泛型类型</td>
</tr>
</tbody>
</table>
<p>除了这两个必需的XML名称空间声明之外，有可能（有时是必要的）在XAML文档的开始元素中定义其他标签前缀。通常，每当需要在XAML中描述外部程序集中定义的.NET类时，都需要这样做。</p>
<p>例如，假设您已经构建了一些自定义WPF控件，并将它们打包在一个名为MyControls.dll的库中。现在，如果要创建一个使用这些控件的新Window，则可以建立一个自定义XML名称空间，该名称空间<strong>使用clr-namespace和Assembly令牌映射到您的库</strong>。以下是一些示例标记，这些标记创建了名为myCtrls的标记前缀，可用于访问库中的控件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">&#34;WpfApplication1.MainWindow&#34;</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
    <span class="na">xmlns:myCtrls=</span><span class="s">&#34;clr-namespace:MyControls;assembly=MyControls&#34;</span>
    <span class="na">Title=</span><span class="s">&#34;MainWindow&#34;</span> <span class="na">Height=</span><span class="s">&#34;350&#34;</span> <span class="na">Width=</span><span class="s">&#34;525&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;myCtrls:MyCustomControl</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>将<strong>clr-namespace令牌</strong>分配给程序集中.NET命名空间的名称，而将<strong>程序集(assembly)令牌</strong>设置为外部*.dll程序集的友好名称。您可以对要在标记中使用的任何外部.NET库使用此语法。尽管目前不需要这样做，但以后的章节将要求您定义自定义XML名称空间声明以描述标记中的类型。</p>
<blockquote>
<p>注意：如果需要在标记中定义一个类，该类是当前程序集的一部分，但在其他.NET命名空间中，则不带assembly= 属性定义xmlns标记前缀，如下所示：
xmlns:myCtrls=&quot;clr-namespace:SomeNamespaceInMyApp&rdquo;</p>
</blockquote>
<h4 id="控制类和成员变量可见性">控制类和成员变量可见性</h4>
<p>在以后的章节中，您会看到许多这样的关键字在起作用。但是，通过一个简单的示例，请考虑以下使用ClassModifier和FieldModifier关键字以及X:Name和x:Class定义的XAML &lt;Window&gt;（请记住，kaxaml.exe将不允许您使用需要代码编译的任何XAML关键字，例如x:Code，x:FieldModifier或x:ClassModifier）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- 现在，该类将在* .g.cs文件中声明为内部类 --&gt;</span>
<span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">&#34;MyWPFApp.MainWindow&#34;</span> <span class="na">x:ClassModifier =</span><span class="s">&#34;internal&#34;</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- This button will be public in the *.g.cs file --&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">x:Name =</span><span class="s">&#34;myButton&#34;</span> <span class="na">x:FieldModifier =</span><span class="s">&#34;public&#34;</span> <span class="na">Content =</span> <span class="s">&#34;OK&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Window&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>默认情况下，所有C＃/ XAML类型定义都是公共的，而成员默认为内部</strong>。但是，根据您的XAML定义，生成的自动生成的文件包含带有公共Button变量的内部类类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">internal</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Window</span><span class="p">,</span>
<span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Markup</span><span class="p">.</span><span class="n">IComponentConnector</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">Button</span> <span class="n">myButton</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="xaml元素xaml属性和类型转换器">XAML元素，XAML属性和类型转换器</h4>
<p>建立根元素和所有必需的XML名称空间后，下一个任务是用子元素填充根元素。在实际的WPF应用程序中，子级将是<strong>布局管理器</strong>（例如Grid或StackPanel），该管理器依次包含描述用户界面的任意数量的其他UI元素。下一章将详细研究这些布局管理器，因此现在仅假设您的&lt;Window&gt;类型将包含一个Button元素。</p>
<p>如本章所述，XAML元素映射到给定.NET命名空间中的类或结构类型，而开始元素标记中的属性映射到该类型的属性或事件。为了说明，在Kaxaml中输入以下&lt;Button&gt;定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="c">&lt;!-- Configure the look and feel of a Button --&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Background=</span><span class="s">&#34;Green&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，分配给每个属性的值已捕获为简单文本值。这似乎是数据类型的完全不匹配，因为如果要用C＃代码制作此Button，则不会将字符串对象分配给这些属性，而是会使用特定的数据类型。例如，这是代码中编写的同一按钮：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">MakeAButton</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Button</span> <span class="n">myBtn</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Button</span><span class="p">();</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Height</span> <span class="p">=</span> <span class="m">50</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Width</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">FontSize</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="s">&#34;OK!&#34;</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Background</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Green</span><span class="p">);</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Foreground</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Yellow</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>事实证明，WPF附带了许多<strong>类型转换器类</strong>，这些类将用于将简单文本值转换为正确的基础数据类型。此过程透明（自动）进行。</p>
<p>尽管这一切都很好，但是在很多情况下，您需要为XAML属性分配更为复杂的值，而该值不能捕获为简单字符串。例如，假设您要构建自定义画笔来设置Button的Background属性。如果要用代码构建画笔，则非常简单，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">public</span> <span class="k">void</span> <span class="n">MakeAButton</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// A fancy brush for the background.
</span><span class="c1"></span>    <span class="n">LinearGradientBrush</span> <span class="n">fancyBruch</span> <span class="p">=</span> 
        <span class="k">new</span> <span class="n">LinearGradientBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">DarkGreen</span><span class="p">,</span> <span class="n">Colors</span><span class="p">.</span><span class="n">LightGreen</span><span class="p">,</span> <span class="m">45</span><span class="p">);</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Background</span> <span class="p">=</span> <span class="n">fancyBruch</span><span class="p">;</span>
    <span class="n">myBtn</span><span class="p">.</span><span class="n">Foreground</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SolidColorBrush</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Yellow</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如何将复杂的画笔表示为字符串？好吧，你不能！值得庆幸的是，XAML提供了一种特殊的语法，该语法在需要将属性值分配给复杂对象时可以使用，称为<strong>属性元素语法</strong>。</p>
<h4 id="了解xaml属性元素语法">了解XAML属性元素语法</h4>
<p>属性元素语法允许您将复杂对象分配给属性。例如这是按钮的XAML描述，该按钮利用LinearGradientBrush设置其Background属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Background&gt;</span>
        <span class="nt">&lt;LinearGradientBrush&gt;</span>
            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">&#34;DarkGreen&#34;</span> <span class="na">Offset=</span><span class="s">&#34;0&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;GradientStop</span> <span class="na">Color=</span><span class="s">&#34;LightGreen&#34;</span> <span class="na">Offset=</span><span class="s">&#34;1&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/LinearGradientBrush&gt;</span>
    <span class="nt">&lt;/Button.Background&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，在&lt;Button&gt;和&lt;/Button&gt;标记的范围内，您定义了一个名为&lt;Button.Background&gt;的子范围。在此范围内，您已定义了一个自定义<!-- raw HTML omitted -->。  （不必担心画笔的确切代码；您将在第28章中了解WPF图形）。</p>
<p>一般而言，可以使用property-element语法设置任何属性，该语法始终会分解为以下模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;DefiningClass&gt;</span>
    <span class="nt">&lt;DefiningClass.PropertyOnDefiningClass&gt;</span>
        <span class="c">&lt;!-- Value for Property here! --&gt;</span>
    <span class="nt">&lt;/DefiningClass.PropertyOnDefiningClass&gt;</span>
<span class="nt">&lt;/DefiningClass&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>尽管可以使用此语法设置任何属性，但是如果可以将值捕获为简单字符串，则可以节省键入时间。例如，以下是设置按钮宽度的详细方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">Content=</span><span class="s">&#34;OK!&#34;</span>
        <span class="na">FontSize=</span><span class="s">&#34;20&#34;</span> <span class="na">Foreground=</span><span class="s">&#34;Yellow&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Button.Width&gt;</span>
        100
    <span class="nt">&lt;/Button.Width&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="了解xaml附加属性">了解XAML附加属性</h4>
<p>除了属性元素语法外，XAML还定义了一种特殊语法，该语法用于为附加属性设置值。本质上，<strong>附加属性</strong>允许子元素设置在父元素中实际定义的属性的值。遵循的通用模板如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;ParentElement&gt;</span>
    <span class="nt">&lt;ChildElement</span> <span class="na">ParentElement.PropertyOnParent =</span> <span class="s">&#34;Value&#34;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/ParentElement&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>附加属性语法的最常见用法是将UI元素放置在WPF布局管理器类之一（Grid，DockPanel等）中。下一章将详细介绍这些面板。现在，在Kaxaml中输入以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Canvas</span> <span class="na">Height=</span><span class="s">&#34;200&#34;</span> <span class="na">Width=</span><span class="s">&#34;200&#34;</span> <span class="na">Background=</span><span class="s">&#34;LightBlue&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Canvas.Top=</span><span class="s">&#34;40&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;40&#34;</span> <span class="na">Height=</span><span class="s">&#34;20&#34;</span> <span class="na">Width=</span><span class="s">&#34;20&#34;</span> <span class="na">Fill=</span><span class="s">&#34;DarkBlue&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Canvas&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，您定义了一个包含Ellipse的Canvas布局管理器。注意，椭圆能够使用附加的属性语法通知其父级（画布）将其顶部/左侧位置放置在何处。</p>
<h4 id="了解xaml标记扩展">了解XAML标记扩展</h4>
<p>如前所述，属性值通常使用简单的字符串或通过property-element语法表示。但是，还有另一种使用标记扩展来指定XAML属性值的方法。<strong>标记扩展</strong>允许XAML解析器从专用的外部类获取属性的值。鉴于某些属性值需要大量代码语句来执行以找出该值，因此这可能是有益的。</p>
<p><strong>标记扩展</strong>提供了一种通过新功能完全扩展XAML语法的方法。标记扩展在内部表示为从MarkupExtension派生的类。请注意，您需要构建自定义标记扩展的机会微乎其微。但是，XAML关键字的子集（例如x:Array，x:Null，x:Static和x:Type）是伪装的标记扩展！</p>
<p><strong>标记扩展名夹在大括号之间</strong>，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Element</span> <span class="na">PropertyToSet =</span> <span class="s">&#34;{MarkUpExtension}&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>要查看实际使用的标记扩展，请将以下内容编写到Kaxaml中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Page</span>
    <span class="na">xmlns=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
    <span class="na">xmlns:x=</span><span class="s">&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
    <span class="na">xmlns:CorLib=</span><span class="s">&#34;clr-namespace:System;assembly=mscorlib&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="c">&lt;!-- 静态标记扩展使我们可以从类的静态成员获取值 --&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Static CorLib:Environment.OSVersion}&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Static CorLib:Environment.ProcessorCount}&#34;</span><span class="nt">/&gt;</span>

        <span class="c">&lt;!-- 类型标记扩展名是C＃typeof运算符的XAML版本 --&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Type Button}&#34;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content =</span><span class="s">&#34;{x:Type CorLib:Boolean}&#34;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!-- 用字符串数组填充ListBox！ --&gt;</span>
        <span class="nt">&lt;ListBox</span> <span class="na">Width=</span><span class="s">&#34;200&#34;</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;ListBox.ItemsSource&gt;</span>
                <span class="nt">&lt;x:Array</span> <span class="na">Type=</span><span class="s">&#34;CorLib:String&#34;</span><span class="nt">&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Sun Kil Moon<span class="nt">&lt;/CorLib:String&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Red House Painters<span class="nt">&lt;/CorLib:String&gt;</span>
                    <span class="nt">&lt;CorLib:String&gt;</span>Besnard Lakes<span class="nt">&lt;/CorLib:String&gt;</span>
                <span class="nt">&lt;/x:Array&gt;</span>
            <span class="nt">&lt;/ListBox.ItemsSource&gt;</span>
        <span class="nt">&lt;/ListBox&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Page&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，请注意Page定义具有新的XML名称空间声明，该声明使您可以访问mscorlib.dll的System名称空间。 建立此XML名称空间后，您首先要使用x:Static标记扩展名并从System.Environment中的OSVersion和ProcessorCount中获取值。</p>
<p>x:Type标记扩展名使您可以访问指定项目的元数据描述。在这里，您只需分配WPF Button和System.Boolean类型的完全限定名称。</p>
<p>此标记最有趣的部分是ListBox。在这里，您将ItemsSource属性设置为完全在标记中声明的字符串数组！在这里注意x:Array标记扩展如何允许您在其范围内指定一组子项目。</p>
<blockquote>
<p>注意: 前面的XAML示例仅用于说明实际使用的标记扩展。正如您将在第25章中看到的那样，有很多更容易的方法来填充ListBox控件！</p>
</blockquote>
<!-- raw HTML omitted -->
<p>现在，您已经看到了无数示例，这些示例展示了XAML语法的每个核心方面。正如您可能同意的那样，XAML很有趣，因为它允许您以声明的方式描述.NET对象树。尽管这在配置图形用户界面时非常有用，但请记住XAML可以描述任何程序集中的任何类型，只要它是包含默认构造函数的非抽象类型即可。</p>
<h3 id="浏览wpf文档">浏览WPF文档</h3>
<p>在结束本章时，我想指出。.NET4.7 Framework SDK文档提供了专门讨论WPF主题的整个部分。在探索此API并阅读其余以WPF为中心的章节时，如果您尽早并经常咨询帮助系统，将会为您提供出色的服务。在这里，您将找到大量的XAML示例以及有关从3D图形编程到复杂的数据绑定操作的各种主题的详细教程。</p>
<p>您可以通过“文档”➤ .NET➤.NET Framework➤Windows Presentation Foundation菜单访问WPF文档。它位于 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/index">https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/index</a>。</p>
<h3 id="概要">概要</h3>
<p>Windows Presentation Foundation（WPF）是 .NET 3.0发行版中引入的用户界面工具包。WPF的主要目标是将许多以前不相关的桌面技术（2D图形，3D图形，窗口和控件开发等）集成和统一到一个统一的编程模型中。除此之外，WPF程序通常使用XAML，它允许您通过标记声明WPF元素的外观。</p>
<p>回想一下XAML允许您使用声明性语法描述.NET对象的树。在本章对XAML的研究中，您接触到了一些新的语法，包括属性元素语法和附加属性，以及类型转换器和XAML标记扩展的作用。</p>
<p>XAML是任何生产级WPF应用程序的关键方面。本章的最后一个示例使您有机会构建一个WPF应用程序，该应用程序显示了本章讨论的许多概念。下一章将深入探讨这些概念，并介绍更多概念。</p>
<h2 id="第25章-wpf控件布局事件和数据绑定">第25章 WPF控件，布局，事件和数据绑定</h2>
<p>第24章为WPF编程模型提供了基础，包括检查Window和Application类，XAML语法以及代码文件的使用。第24章还向您介绍了使用Visual Studio设计器构建WPF应用程序的过程。在本章中，您将使用几个新的控件和布局管理器来研究更复杂的图形用户界面的构造，并逐步了解Visual Studio的WPF设计器的其他功能。</p>
<p>本章还将研究一些重要的WPF相关控制主题，例如数据绑定编程模型和控制命令的使用。您还将学习如何使用Ink和Documents API，使用它们可以捕获手写笔（或鼠标）输入并分别使用XML Paper Specification生成RTF文档。</p>
<h3 id="wpf核心控件概述">WPF核心控件概述</h3>
<p>除非您不熟悉构建图形用户界面的概念（这没关系），否则主要WPF控件的一般用途不应引起太多问题。无论您过去使用过哪种GUI工具包（例如，VB 6.0，MFC，Java AWT / Swing，Windows Forms，macOS或GTK+ / GTK＃等），表25-1中列出的WPF核心控件可能看起来都会很熟悉。</p>
<h4 id="wpf-ink-控件">WPF Ink 控件</h4>
<p>除了表25-1中列出的通用WPF控件外，WPF还定义了用于与数字Ink API配合使用的其他控件。WPF开发的这一方面在Tablet PC开发期间非常有用，因为它使您可以从笔中捕获输入。但是，这并不是说标准的桌面应用程序无法利用Ink API，因为相同的控件可以使用鼠标捕获输入。</p>
<p>PresentationCore.dll的System.Windows.Ink命名空间包含各种Ink API支持类型（例如Stroke和StrokeCollection）；但是，大多数Ink API控件（例如InkCanvas和InkPresenter）与通用WPF控件一起打包在PresentationFramework.dll程序集的System.Windows.Controls命名空间下。本章稍后将使用Ink API。</p>
<h4 id="wpf文档控件">WPF文档控件</h4>
<p>WPF还提供了用于高级文档处理的控件，使您可以构建包含Adobe PDF样式功能的应用程序。使用System.Windows.Documents命名空间（同样在PresentationFramework.dll程序集中）中的类型，可以创建支持缩放，搜索，用户注释（便笺）和其他RTF服务的可打印文档。</p>
<p>然而，在幕后，文档控件不使用Adobe PDF API。 而是使用XML Paper Specification（XPS）API。对于最终用户来说，实际上似乎没有什么区别，因为PDF文档和XPS文档具有几乎相同的外观。实际上，您可以找到许多免费的实用程序，使您可以即时在两种文件格式之间进行转换。由于篇幅所限，本版本将不涉及这些控件。</p>
<h4 id="wpf通用对话框">WPF通用对话框</h4>
<p>WPF还为您提供了一些常用对话框，例如OpenFileDialog和SaveFileDialog。这些对话框在PresentationFramework.dll程序集的Microsoft.Win32命名空间中定义。使用这些对话框中的任何一个都需要创建一个对象并调用ShowDialog()方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">Microsoft.Win32</span><span class="p">;</span>
<span class="c1">//omitted for brevity
</span><span class="c1"></span><span class="k">private</span> <span class="k">void</span> <span class="n">btnShowDlg_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Show a file save dialog.
</span><span class="c1"></span>    <span class="n">SaveFileDialog</span> <span class="n">saveDlg</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SaveFileDialog</span><span class="p">();</span>
    <span class="n">saveDlg</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>正如您希望的那样，这些类支持各种成员，这些成员使您可以建立文件过滤器和目录路径，并访问用户选择的文件。您将在以后的示例中使用这些文件对话框。您还将学习如何构建自定义对话框来收集用户输入。</p>
<h3 id="使用面板控制内容布局">使用面板控制内容布局</h3>
<p>您还可以在其他面板（例如，包含其他项目的StackPanel的DockPanel）内混合面板控件，以提供很大的灵活性和控件。表25-2记录了一些常用的WPF面板控件的作用。</p>
<table>
<thead>
<tr>
<th align="center">面板控件</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Canvas</td>
<td align="left">提供经典的内容放置方式。在设计时，物品会完全保留在您放置它们的位置。</td>
</tr>
<tr>
<td align="center">DockPanel</td>
<td align="left">将内容锁定到面板的指定侧（顶部，底部，左侧或右侧）。</td>
</tr>
<tr>
<td align="center">Grid</td>
<td align="left">在表格单元格中维护的一系列单元格中排列内容。</td>
</tr>
<tr>
<td align="center">StackPanel</td>
<td align="left">根据Orientation属性的要求，以垂直或水平方式堆叠内容。</td>
</tr>
<tr>
<td align="center">WrapPanel</td>
<td align="left">将内容从左到右放置，将内容中断到包含框边缘的下一行。 随后的顺序从上到下或从右到左顺序发生，具体取决于Orientation属性的值。</td>
</tr>
</tbody>
</table>
<p>在接下来的几节中，您将通过将一些预定义的XAML数据复制到在第24章中安装的kaxaml.exe应用程序中，学习如何使用这些常用的面板类型。您可以在您的第25章代码下载文件夹PanelMarkup子文件夹中找到所有这些宽松的XAML文件。使用Kaxaml时，要模拟调整窗口的大小，请更改标记中Page元素的高度或宽度。</p>
<h3 id="使用嵌套面板构建窗口框架">使用嵌套面板构建窗口框架</h3>
<h3 id="了解wpf命令">了解WPF命令</h3>
<p>WPF通过命令体系结构为可能被认为与控制无关的事件提供支持。典型的.NET事件是在特定的基类中定义的，并且只能由该类或其派生类使用。因此，普通的.NET事件与定义它们的类紧密相关。</p>
<p>相反，WPF命令是类似事件的实体，独立于特定控件，并且在许多情况下可以成功地应用于多种（看似无关）的控件类型。举几个例子，WPF支持复制，粘贴和剪切命令，您可以将其应用于各种UI元素（例如，菜单项，工具栏按钮和自定义按钮）以及键盘快捷键（例如，Ctrl+C 和 Ctrl+V）。</p>
<p>虽然其他UI工具包（例如Windows Forms）为此目的提供了标准事件，但使用它们通常会给您留下冗余且难以维护的代码。在WPF模型下，您可以使用命令作为替代。最终结果通常会产生更小，更灵活的代码库。</p>
<h3 id="了解路由事件">了解路由事件</h3>
<p>您可能已经注意到上一个代码示例中的RoutedEventArgs参数而不是EventArgs。<strong>路由事件</strong>模型是对标准CLR事件模型的改进，该模型旨在确保可以以适合XAML对对象树的描述的方式来处理事件。假设您有一个名为WPFRoutedEvents的新WPF应用程序项目。现在，通过添加下面的Button控件来更新初始窗口的XAML描述，该按钮定义了一些复杂的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">&#34;btnClickMe&#34;</span> <span class="na">Height=</span><span class="s">&#34;75&#34;</span> <span class="na">Width =</span> <span class="s">&#34;250&#34;</span> <span class="na">Click =</span><span class="s">&#34;btnClickMe_Clicked&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span><span class="nt">&gt;</span>Fancy Button!<span class="nt">&lt;/Label&gt;</span>
        <span class="nt">&lt;Canvas</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;100&#34;</span> <span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span> <span class="na">Height =</span><span class="s">&#34;25&#34;</span>
            <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;innerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Yellow&#34;</span> <span class="na">Height =</span> <span class="s">&#34;15&#34;</span> <span class="na">Width =</span><span class="s">&#34;36&#34;</span>
            <span class="na">Canvas.Top=</span><span class="s">&#34;17&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;32&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Canvas&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，在Button的开头定义中，您已经通过指定引发事件时要调用的方法的名称来处理Click事件。Click事件与RoutedEventHandler委托一起使用，该委托期望一个事件处理程序以一个对象作为第一个参数，并使用System.Windows.RoutedEventArgs作为第二个。如此实现此处理程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">btnClickMe_Clicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Do something when button is clicked.
</span><span class="c1"></span>    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Clicked the button&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果您运行应用程序，则无论您单击按钮内容的哪一部分（绿色的椭圆，黄色的椭圆，标签或按钮的表面），都会看到此消息框显示。这是一件好事。想象一下，如果您被迫为每个子元素处理Click事件，那么WPF事件处理将是多么繁琐。为Button的每个方面创建单独的事件处理程序不仅会很费力，而且您最终还会得到一些强大的令人讨厌的代码来维护。</p>
<p>值得庆幸的是，WPF路由事件可以确保无论自动单击按钮的哪一部分，都将调用单个Click事件处理程序。简而言之，路由事件模型自动在对象树上（或下）传播事件，以寻找合适的处理程序。</p>
<p>具体来说，<strong>路由事件</strong>可以利用三种<strong>路由策略</strong>。如果事件正在从源点移动到对象树中的其他定义范围，则该事件被称为<strong>冒泡事件</strong>。相反，如果事件从最外面的元素（例如，窗口）向下移动到起点，则该事件被称为<strong>隧道事件</strong>。最后，如果仅由始发元素引发和处理事件（可以将其描述为正常CLR事件），则将其称为<strong>直接事件</strong>。</p>
<h4 id="路由冒泡事件的作用">路由冒泡事件的作用</h4>
<p>在当前示例中，如果用户单击内部的黄色椭圆形，则Click事件冒出到下一级作用域（画布），然后到StackPanel，最后到处理Click事件处理程序的Button。以类似的方式，如果用户单击Label，则事件将冒泡到StackPanel，然后最终冒泡到Button元素。</p>
<p>有了这种冒泡的路由事件模式，您就不必担心为复合控件的所有成员注册特定的Click事件处理程序。但是，如果要对同一对象树中的多个元素执行自定义单击逻辑，则可以执行此操作。</p>
<p>举例说明，假设您需要以独特的方式处理externalEllipse控件的单击。首先，处理此子元素的MouseDown事件（图形呈现的类型，例如Ellipse不支持Click事件；但是，它们可以通过MouseDown，MouseUp等监视鼠标按钮的活动）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Name=</span><span class="s">&#34;btnClickMe&#34;</span> <span class="na">Height=</span><span class="s">&#34;75&#34;</span> <span class="na">Width =</span> <span class="s">&#34;250&#34;</span> <span class="na">Click =</span><span class="s">&#34;btnClickMe_Clicked&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Height=</span><span class="s">&#34;50&#34;</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span><span class="nt">&gt;</span>Fancy Button!<span class="nt">&lt;/Label&gt;</span>
        <span class="nt">&lt;Canvas</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;100&#34;</span> <span class="nt">&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span>
            <span class="na">Height =</span><span class="s">&#34;25&#34;</span> <span class="na">MouseDown =</span><span class="s">&#34;outerEllipse_MouseDown&#34;</span>
            <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;innerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Yellow&#34;</span> <span class="na">Height =</span> <span class="s">&#34;15&#34;</span> <span class="na">Width =</span><span class="s">&#34;36&#34;</span>
            <span class="na">Canvas.Top=</span><span class="s">&#34;17&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;32&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/Canvas&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Button&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>然后实现一个适当的事件处理程序，出于说明目的，该事件处理程序将仅更改主窗口的Title属性，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change title of window.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">Title</span> <span class="p">=</span> <span class="s">&#34;You clicked the outer ellipse!&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，您现在可以根据最终用户单击的位置（归结为外部椭圆以及按钮范围内的所有其他位置）采取不同的操作方式。</p>
<blockquote>
<p>注意: 路由冒泡事件始终从原点移动到下一个定义范围。因此，在此示例中，如果单击innerEllipse对象，则事件将冒泡到Canvas，而不是到externalEllipse，因为它们都是Canvas范围内的Ellipse类型。</p>
</blockquote>
<h4 id="继续或停止冒泡">继续或停止冒泡</h4>
<p>当前，如果用户单击outerEllipse对象，它将触发为此Ellipse对象注册的MouseDown事件处理程序，此时该事件会冒泡到按钮的Click事件。如果要通知WPF停止冒泡对象树，可以将EventArgs参数的Handled属性设置为true，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change title of window.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">Title</span> <span class="p">=</span> <span class="s">&#34;You clicked the outer ellipse!&#34;</span><span class="p">;</span>
    <span class="c1">// Stop bubbling!
</span><span class="c1"></span>    <span class="n">e</span><span class="p">.</span><span class="n">Handled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种情况下，您会发现窗口的标题已更改，但是您将看不到Button的Click事件处理程序显示的MessageBox。 简而言之，路由冒泡事件可以使一组复杂的内容充当单个逻辑元素（例如Button）或离散项（例如Button中的Ellipse）。</p>
<h4 id="路由隧道事件的作用">路由隧道事件的作用</h4>
<p>严格来说，路由事件实际上可以是冒泡的（如刚刚描述的）或隧穿的 隧道事件（所有事件均以Preview后缀开头-例如PreviewMouseDown）从最顶层的元素向下钻入对象树的内部范围。总的来说，WPF基类库中的每个冒泡事件都与一个相关的隧道事件配对，该事件在冒泡对象之前触发。例如，在启动冒泡的MouseDown事件之前，将先触发隧道化PreviewMouseDown事件。</p>
<p>处理隧道事件看起来就像处理其他任何事件一样。只需在XAML中分配事件处理程序名称即可（或者，如果需要，在代码文件中使用相应的C＃事件处理语法），然后在代码文件中实现处理程序。只是为了说明隧道事件和冒泡事件之间的相互作用，首先要处理externalEllipse对象的PreviewMouseDown事件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Ellipse</span> <span class="na">Name =</span> <span class="s">&#34;outerEllipse&#34;</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span> <span class="na">Height =</span><span class="s">&#34;25&#34;</span>
        <span class="na">MouseDown =</span><span class="s">&#34;outerEllipse_MouseDown&#34;</span>
        <span class="na">PreviewMouseDown =</span><span class="s">&#34;outerEllipse_PreviewMouseDown&#34;</span>
        <span class="na">Width =</span><span class="s">&#34;50&#34;</span> <span class="na">Cursor=</span><span class="s">&#34;Hand&#34;</span> <span class="na">Canvas.Left=</span><span class="s">&#34;25&#34;</span> <span class="na">Canvas.Top=</span><span class="s">&#34;12&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来，通过使用传入事件args对象更新每个事件处理程序（针对所有对象）以更新当前C＃类定义，以将有关当前事件的数据附加到名为mouseActivity的字符串成员变量中。这将使您观察后台触发的事件流。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">_mouseActivity</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">InitializeComponent</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="n">btnClickMe_Clicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">_mouseActivity</span><span class="p">,</span> <span class="s">&#34;Your Event Info&#34;</span><span class="p">);</span>
        <span class="c1">// Clear string for next round.
</span><span class="c1"></span>        <span class="n">_mouseActivity</span> <span class="p">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">AddEventInfo</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_mouseActivity</span> <span class="p">+=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span>
            <span class="s">&#34;{0} sent a {1} event named {2}.\n&#34;</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">RoutedEvent</span><span class="p">.</span><span class="n">RoutingStrategy</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">RoutedEvent</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">outerEllipse_MouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">outerEllipse_PreviewMouseDown</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">MouseButtonEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddEventInfo</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，您不会停止任何事件处理程序的事件冒泡。如果运行此应用程序，则将根据单击按钮的位置显示唯一的消息框。图25-15显示了单击外部Ellipse对象的结果。</p>
<!-- raw HTML omitted -->
<p>那么，为什么WPF事件通常倾向于成对出现（一个隧道和一个冒泡）？ 答案是，通过预览事件，您可以在启动冒泡对象之前执行任何特殊的逻辑（数据验证，禁用冒泡操作等）。举例来说，假设您有一个TextBox，它只应包含数字数据。您可以处理PreviewKeyDown事件，并且如果看到用户输入了非数字数据，则可以通过将Handled属性设置为true来取消冒泡事件。</p>
<p>就像您猜到的那样，当您构建包含自定义事件的自定义控件时，您可以通过以下方式创作事件：事件可以在XAML树中冒泡（或隧穿）。就本章而言，我不会研究如何构建自定义路由事件（但是，该过程与构建自定义依赖项属性没有什么不同）。如果您有兴趣，请查看 .NET Framework 4.7 SDK文档中的“路由事件概述”主题。 在其中，您会找到许多可以帮助您的教程。</p>
<h3 id="深入了解wpf-api和控件">深入了解WPF API和控件</h3>
<p>本章的其余部分将使您有机会使用Visual Studio构建新的WPF应用程序。目标是创建一个由包含一组选项卡的TabControl小部件组成的UI。每个选项卡将说明您可能希望在软件项目中使用的一些新的WPF控件和有趣的API。在此过程中，您还将学习Visual Studio WPF设计器的其他功能。</p>
<h4 id="使用tabcontrol">使用TabControl</h4>
<p>首先，创建一个名为WpfControlsAndAPIs的新WPF应用程序。如前所述，您的初始窗口将包含一个带有三个不同选项卡的TabControl，每个选项卡都展示了一组相关的控件和/或WPF API。 将窗口的宽度更新为800，高度更新为350。</p>
<p>在Visual Studio工具箱中找到TabControl控件，将其放到设计器中，然后将标记更新为以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="p">&lt;</span><span class="n">TabControl</span> <span class="n">Name</span><span class="p">=</span><span class="s">&#34;MyTabControl&#34;</span> <span class="n">HorizontalAlignment</span><span class="p">=</span><span class="s">&#34;Stretch&#34;</span> <span class="n">VerticalAlignment</span><span class="p">=</span><span class="s">&#34;Stretch&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">TabItem</span> <span class="n">Header</span><span class="p">=</span><span class="s">&#34;TabItem&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">Grid</span> <span class="n">Background</span><span class="p">=</span><span class="s">&#34;#FFE5E5E5&#34;</span><span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="n">TabItem</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">TabItem</span> <span class="n">Header</span><span class="p">=</span><span class="s">&#34;TabItem&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">Grid</span> <span class="n">Background</span><span class="p">=</span><span class="s">&#34;#FFE5E5E5&#34;</span><span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="n">TabItem</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">TabControl</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>您会注意到，系统将自动为您提供两个选项卡项。要添加其他选项卡，只需在Document Outline窗口中右键单击TabControl节点，然后选择Add TabItem菜单选项（也可以在设计器上右键单击TabControl来激活相同的菜单选项），或者只是开始输入 在XAML编辑器中。使用任一方法添加一个附加选项卡。</p>
<p>现在，通过XAML编辑器更新每个TabItem控件，并更改每个选项卡的Header属性，将它们命名为Ink API，Data Binding和DataGrid。此时，您的窗口设计器应如图25-16所示。</p>
<!-- raw HTML omitted -->
<p>要知道，当你选择一个标签进行编辑，该选项卡成为活动选项卡，你可以从工具箱窗口中拖动控制设计该选项卡。现在，您已经定义了核心的TabControl，您可以逐个标签地制定详细信息，并逐步了解WPF API的更多功能。</p>
<h3 id="构建ink-api标签">构建Ink API标签</h3>
<p>第一个标签将用于显示WPF数字墨水API的总体作用，使您可以轻松地将绘画功能整合到程序中。当然，该应用程序实际上不需要是绘画应用程序；您可以将此API用于多种用途，包括捕获手写输入。</p>
<blockquote>
<p>注意: 对于本章的其余大部分（以及WPF的下一章），我将直接编辑XAML，而不是使用各种窗口。尽管控件可以工作，但布局不是您想要的（Visual Studio根据控件的放置位置增加了边距和内边距），这样你将花费大量时间清理XAML。</p>
</blockquote>
<p>首先将Ink API TabItem下的Grid标记更改为StackPanel并添加一个结束标记（确保从开始标记中删除“ /”）。 您的标记应如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;TabItem</span> <span class="na">Header=</span><span class="s">&#34;Ink API&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Background=</span><span class="s">&#34;#FFE5E5E5&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/TabItem&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="设计工具栏">设计工具栏</h4>
<p>添加一个名为InkToolbar的新工具栏控件（使用XAML编辑器），高度为60。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;ToolBar</span> <span class="na">Name=</span><span class="s">&#34;InkToolBar&#34;</span> <span class="na">Height=</span><span class="s">&#34;60&#34;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/ToolBar&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>在Border控件内部的WrapPanel内部添加三个RadioButton控件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Border</span> <span class="na">Margin=</span><span class="s">&#34;0,2,0,2.4&#34;</span> <span class="na">Width=</span><span class="s">&#34;280&#34;</span> <span class="na">VerticalAlignment=</span><span class="s">&#34;Center&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;WrapPanel&gt;</span>
        <span class="nt">&lt;RadioButton</span> <span class="na">x:Name=</span><span class="s">&#34;inkRadio&#34;</span> <span class="na">Margin=</span><span class="s">&#34;5,10&#34;</span> <span class="na">Content=</span><span class="s">&#34;Ink Mode!&#34;</span> <span class="na">IsChecked=</span><span class="s">&#34;True&#34;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;RadioButton</span> <span class="na">x:Name=</span><span class="s">&#34;eraseRadio&#34;</span> <span class="na">Margin=</span><span class="s">&#34;5,10&#34;</span> <span class="na">Content=</span><span class="s">&#34;Erase Mode!&#34;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;RadioButton</span> <span class="na">x:Name=</span><span class="s">&#34;selectRadio&#34;</span> <span class="na">Margin=</span><span class="s">&#34;5,10&#34;</span> <span class="na">Content=</span><span class="s">&#34;Select Mode!&#34;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/WrapPanel&gt;</span>
<span class="nt">&lt;/Border&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>当RadioButton控件未放置在父面板控件内部时，它将具有与Button控件相同的UI！ 这就是为什么我将RadioButton控件包装在WrapPanel中的原因。</p>
<p>接下来，添加一个分隔符，然后添加一个宽度为175，边距为10,0,0,0的ComboBox。 添加三个具有红色，绿色和蓝色内容的ComboBoxItem标签，并在整个ComboBox后面添加另一个Separator控件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Separator/&gt;</span>
    <span class="nt">&lt;ComboBox</span> <span class="na">x:Name=</span><span class="s">&#34;comboColors&#34;</span> <span class="na">Width=</span><span class="s">&#34;175&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,0,0,0&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Red&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Green&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Blue&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/ComboBox&gt;</span>
<span class="nt">&lt;Separator/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="单选按钮控件">单选按钮控件</h4>
<p>在此示例中，您希望这三个RadioButton控件互斥。在其他GUI框架中，要确保一组相关控件（例如单选按钮）是互斥的，则需要将它们放在同一组框中。您无需在WPF下执行此操作。相反，您可以简单地将它们全部分配给相同的组名。 这很有用，因为相关项目不需要实际收集在同一区域中，而是可以放置在窗口中的任何位置。</p>
<p>RadioButton类包含一个IsChecked属性，当最终用户单击UI元素时，该属性将在true和false之间切换。 此外，RadioButton提供了两个事件（“Checked”和“Unchecked”），可用于拦截此状态更改。</p>
<h4 id="添加保存加载和删除按钮">添加保存，加载和删除按钮</h4>
<p>ToolBar控件中的最终控件将是一个网格，其中包含三个Button控件。在最后一个Separator控件之后添加以下标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;Grid.ColumnDefinitions&gt;</span>
        <span class="nt">&lt;ColumnDefinition</span> <span class="na">Width=</span><span class="s">&#34;Auto&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;ColumnDefinition</span> <span class="na">Width=</span><span class="s">&#34;Auto&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;ColumnDefinition</span> <span class="na">Width=</span><span class="s">&#34;Auto&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid.ColumnDefinitions&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;0&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnSave&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Save Data&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;1&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnLoad&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Load Data&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;2&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnClear&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Clear&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Grid&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="添加inkcanvas控件">添加InkCanvas控件</h4>
<p>TabControl的最终控件是InkCanvas控件。 在结束的ToolBar标记之后和结束的StackPanel标记之前添加以下标记，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;InkCanvas</span> <span class="na">x:Name=</span><span class="s">&#34;MyInkCanvas&#34;</span> <span class="na">Background=</span><span class="s">&#34;#FFB6F4F1&#34;</span> <span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="预览窗口">预览窗口</h4>
<p>此时，您可以测试程序了，您可以按F5键。现在，您应该看到三个互斥的单选按钮，一个带有三个选项的组合框和三个按钮（见图25-17）。</p>
<!-- raw HTML omitted -->
<h4 id="处理ink-api选项卡的事件">处理Ink API选项卡的事件</h4>
<p>Ink API选项卡的下一步是处理每个RadioButton控件的Click事件。就像在本书的其他WPF项目中所做的那样，只需单击Visual Studio属性编辑器的闪电图标即可输入事件处理程序的名称。使用这种方法，将每个按钮的Click事件路由到名为RadioButtonClicked的同一处理程序。处理所有三个Click事件之后，使用名为ColorChanged的处理程序处理ComboBox的SelectionChanged事件。完成后，您应该具有以下C＃代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">InitializeComponent</span><span class="p">();</span>
        <span class="c1">// Insert code required on object creation below this point.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">private</span> <span class="k">void</span> <span class="n">RadioButtonClicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span><span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// TODO: Add event handler implementation here.
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="n">ColorChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span><span class="n">SelectionChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// TODO: Add event handler implementation here.
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>您将在以后的步骤中实现这些处理程序，因此暂时将它们留空。</p>
<h4 id="将控件添加到工具箱">将控件添加到工具箱</h4>
<p>您通过直接编辑XAML添加了InkCanvas控件。如果要使用UI进行添加，则默认情况下，Visual Studio工具箱不会向您显示所有可能的WPF组件。但是您可以更新工具箱中显示的项目。</p>
<p>这样做，右键单击“工具箱”区域中的任何位置，然后选择“选择项目”菜单选项。 一两分钟后，您将看到要添加到工具箱的可能组件的列表。为了您的目的，您有兴趣添加InkCanvas控件（请参见图25-18）。</p>
<h4 id="inkcanvas控件">InkCanvas控件</h4>
<p>只需添加InkCanvas，即可在窗口中绘图。您可以使用鼠标，或者，如果您有启用触摸的设备，则可以使用手指或数字笔。运行该应用程序并绘制到框中（请参见图25-19）。</p>
<p><img src="http://note.youdao.com/yws/public/resource/cb5db1b8454acbb910a8ffbc7d9d4d1f/xmlnote/1C45EFB81A524D6981F7C9A767DB8AD9/3285" alt="图25-19"></p>
<p>InkCanvas的功能不只是绘制鼠标（或手写笔）的笔划。 它还支持许多独特的编辑模式，这些模式由EditingMode属性控制。您可以从相关的InkCanvasEditingMode枚举中为该属性分配任何值。在此示例中，您对Ink Mode感兴趣，这是您刚刚看到的默认选项。Select Mode，允许用户使用鼠标选择区域以移动或调整大小；和EraseByStoke，这将删除先前的鼠标笔触。</p>
<blockquote>
<p>注意: 笔触是​​一次鼠标下移/鼠标上移操作期间发生的渲染。InkCanvas将所有笔划存储在StrokeCollection对象中，您可以使用Strokes属性对其进行访问。</p>
</blockquote>
<p>使用以下逻辑更新您的RadioButtonClicked()处理程序，该逻辑根据选定的RadioButton将InkCanvas置于正确的模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">RadioButtonClicked</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span><span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Based on which button sent the event, place the InkCanvas in a unique
</span><span class="c1"></span>    <span class="c1">// mode of operation.
</span><span class="c1"></span>    <span class="k">switch</span><span class="p">((</span><span class="n">sender</span> <span class="k">as</span> <span class="n">RadioButton</span><span class="p">)?.</span><span class="n">Content</span><span class="p">.</span><span class="n">ToString</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// These strings must be the same as the Content values for each
</span><span class="c1"></span>        <span class="c1">// RadioButton.
</span><span class="c1"></span>        <span class="k">case</span> <span class="s">&#34;Ink Mode!&#34;</span><span class="p">:</span>
            <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">EditingMode</span> <span class="p">=</span> <span class="n">InkCanvasEditingMode</span><span class="p">.</span><span class="n">Ink</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="s">&#34;Erase Mode!&#34;</span><span class="p">:</span>
            <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">EditingMode</span> <span class="p">=</span> <span class="n">InkCanvasEditingMode</span><span class="p">.</span><span class="n">EraseByStroke</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="s">&#34;Select Mode!&#34;</span><span class="p">:</span>
            <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">EditingMode</span> <span class="p">=</span> <span class="n">InkCanvasEditingMode</span><span class="p">.</span><span class="n">Select</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另外，在窗口的构造函数中，默认情况下将模式设置为“Ink”。在使用它时，请为ComboBox设置一个默认选择（下一节中有关此控件的更多详细信息），如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">MainWindow</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">InitializeComponent</span><span class="p">();</span>

    <span class="c1">// Be in Ink mode by default.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">EditingMode</span> <span class="p">=</span> <span class="n">InkCanvasEditingMode</span><span class="p">.</span><span class="n">Ink</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">inkRadio</span><span class="p">.</span><span class="n">IsChecked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">comboColors</span><span class="p">.</span><span class="n">SelectedIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，按F5再次运行程序。进入墨水模式并绘制一些数据。接下来，进入“擦除”模式并删除您输入的上一个鼠标笔划（您会注意到鼠标图标自动看起来像一个橡皮擦）。最后，进入“选择”模式，然后使用鼠标作为套索来选择一些笔触。</p>
<p>圈出项目后，可以在画布上移动它并调整其尺寸。 图25-20显示了您的工作编辑模式。</p>
<p><img src="http://note.youdao.com/yws/public/resource/cb5db1b8454acbb910a8ffbc7d9d4d1f/xmlnote/3930ED0E28B84143B6E4C0DE61C6C384/3287" alt="图25-20"></p>
<h4 id="combobox控件">ComboBox控件</h4>
<p>填充ComboBox控件（或ListBox）后，可以通过三种方法确定所选项目。首先，如果要查找所选项目的数字索引，可以使用SelectedIndex属性（从零开始；值-1表示没有选择）。其次，如果要在已选择的列表中获取对象，则SelectedItem属性很合适。第三，SelectedValue允许您获取所选对象的值（通常使用对ToString（）的调用获得）。</p>
<p>您需要为此选项卡添加代码的最后一位，以更改在InkCanvas上输入的笔触颜色。InkCanvas的DefaultDrawingAttributes属性返回一个DrawingAttributes对象，该对象使您可以配置笔尖的多个方面，包括其大小和颜色（以及其他设置）。使用ColorChanged（）方法的以下实现更新您的C＃代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">ColorChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">SelectionChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get the selected value in the combo box.
</span><span class="c1"></span>    <span class="kt">string</span> <span class="n">colorToUse</span> <span class="p">=</span>
        <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">comboColors</span><span class="p">.</span><span class="n">SelectedItem</span> <span class="k">as</span> <span class="n">ComboBoxItem</span><span class="p">)?.</span><span class="n">Content</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
    <span class="c1">// Change the color used to render the strokes.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">DefaultDrawingAttributes</span><span class="p">.</span><span class="n">Color</span> <span class="p">=</span>
        <span class="p">(</span><span class="n">Color</span><span class="p">)</span><span class="n">ColorConverter</span><span class="p">.</span><span class="n">ConvertFromString</span><span class="p">(</span><span class="n">colorToUse</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在回想一下，ComboBox具有ComboBoxItems的集合。如果您查看生成的XAML，则会看到以下定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;ComboBox</span> <span class="na">x:Name=</span><span class="s">&#34;comboColors&#34;</span> <span class="na">Width=</span><span class="s">&#34;100&#34;</span> <span class="na">SelectionChanged=</span><span class="s">&#34;ColorChanged&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Red&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Green&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;ComboBoxItem</span> <span class="na">Content=</span><span class="s">&#34;Blue&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/ComboBox&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>调用SelectedItem时，将获取选定的ComboBoxItem，该ComboBoxItem存储为常规对象。将对象强制转换为ComboBoxItem之后，您将拔出Content的值，该值将为字符串Red，Green或Blue。然后，使用方便的ColorConverter实用程序类将此字符串转换为Color对象。现在再次运行您的程序。渲染图像时，您应该能够在颜色之间进行更改。</p>
<p>请注意，ComboBox和ListBox控件也可以包含复杂的内容，而不是文本数据列表。您可以通过打开窗口的XAML编辑器并更改ComboBox的定义来了解可能发生的事情，以便它包含一组StackPanel元素，每个元素都包含一个Ellipse和Label（请注意，组合框的宽度为175）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;ComboBox</span> <span class="na">x:Name=</span><span class="s">&#34;comboColors&#34;</span> <span class="na">Width=</span><span class="s">&#34;175&#34;</span> <span class="na">Margin=</span><span class="s">”10,0,0,0”</span> <span class="na">SelectionChanged=</span><span class="s">&#34;ColorChang
</span><span class="s">ed&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span> <span class="na">Tag=</span><span class="s">&#34;Red&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill =</span><span class="s">&#34;Red&#34;</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span> <span class="na">HorizontalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">VerticalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">Content=</span><span class="s">&#34;Red&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>

    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span> <span class="na">Tag=</span><span class="s">&#34;Green&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill =</span><span class="s">&#34;Green&#34;</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span> <span class="na">HorizontalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">VerticalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">Content=</span><span class="s">&#34;Green&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>

    <span class="nt">&lt;StackPanel</span> <span class="na">Orientation =</span><span class="s">&#34;Horizontal&#34;</span> <span class="na">Tag=</span><span class="s">&#34;Blue&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Ellipse</span> <span class="na">Fill =</span><span class="s">&#34;Blue&#34;</span> <span class="na">Height =</span><span class="s">&#34;50&#34;</span> <span class="na">Width =</span><span class="s">&#34;50&#34;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">FontSize =</span><span class="s">&#34;20&#34;</span> <span class="na">HorizontalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">VerticalAlignment=</span><span class="s">&#34;Center&#34;</span> <span class="na">Content=</span><span class="s">&#34;Blue&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/ComboBox&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，每个StackPanel都为其Tag属性分配一个值，这是一种简单，快速且方便的方法来发现用户已选择的项目堆栈（有更好的方法，但是现在可以这样做）。进行此调整后，您需要更改ColorChanged（）方法的实现，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">ColorChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">SelectionChangedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get the Tag of the selected StackPanel.
</span><span class="c1"></span>    <span class="kt">string</span> <span class="n">colorToUse</span> <span class="p">=</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">comboColors</span><span class="p">.</span><span class="n">SelectedItem</span>
    <span class="k">as</span> <span class="n">StackPanel</span><span class="p">).</span><span class="n">Tag</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在再次运行程序，并记下您独特的ComboBox（见图25-21）。</p>
<h4 id="保存加载和清除inkcanvas数据">保存，加载和清除InkCanvas数据</h4>
<p>此选项卡的最后一部分将使您能够保存和加载画布数据，以及通过为工具栏中的按钮添加事件处理程序清除其所有内容。 通过为单击事件添加标记来更新按钮的XAML，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;0&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnSave&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Save Data&#34;</span>
<span class="na">Click=</span><span class="s">&#34;SaveData&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;1&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnLoad&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Load Data&#34;</span>
<span class="na">Click=</span><span class="s">&#34;LoadData&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">Grid.Column=</span><span class="s">&#34;2&#34;</span> <span class="na">x:Name=</span><span class="s">&#34;btnClear&#34;</span> <span class="na">Margin=</span><span class="s">&#34;10,10&#34;</span> <span class="na">Width=</span><span class="s">&#34;70&#34;</span> <span class="na">Content=</span><span class="s">&#34;Clear&#34;</span>
<span class="na">Click=</span><span class="s">&#34;Clear&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来，将System.IO和System.Windows.Ink命名空间导入到您的代码文件中。实现处理程序，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">SaveData</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Save all data on the InkCanvas to a local file.
</span><span class="c1"></span>    <span class="k">using</span> <span class="p">(</span><span class="n">FileStream</span> <span class="n">fs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FileStream</span><span class="p">(</span><span class="s">&#34;StrokeData.bin&#34;</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Create</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">Strokes</span><span class="p">.</span><span class="n">Save</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
        <span class="n">fs</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="n">LoadData</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Fill StrokeCollection from file.
</span><span class="c1"></span>    <span class="n">using</span><span class="p">(</span><span class="n">FileStream</span> <span class="n">fs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FileStream</span><span class="p">(</span><span class="s">&#34;StrokeData.bin&#34;</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">,</span> <span class="n">FileAccess</span><span class="p">.</span><span class="n">Read</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">StrokeCollection</span> <span class="n">strokes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StrokeCollection</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">Strokes</span> <span class="p">=</span> <span class="n">strokes</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="n">Clear</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Clear all strokes.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">MyInkCanvas</span><span class="p">.</span><span class="n">Strokes</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，您应该能够将数据保存到文件中，从文件中加载它，并清除所有数据的InkCanvas。 这包含了TabControl的第一个选项卡，以及对WPF数字墨水API的检查。 可以肯定的是，关于这项技术还有更多的话要说。但是，如果您感兴趣，您应该处于很好的位置，可以进一步深入研究该主题。接下来，您将学习如何使用WPF数据绑定。</p>
<h3 id="介绍wpf数据绑定模型">介绍WPF数据绑定模型</h3>
<p>控件通常是各种数据绑定操作的目标。简而言之，<strong>数据绑定是将控件属性连接到在应用程序生命周期中可能发生变化的数据值的行为</strong>。这样做<strong>可以使用户界面元素在代码中显示变量的状态</strong>。例如，您可以使用数据绑定来完成以下任务：</p>
<ul>
<li>根据给定对象的布尔属性检查CheckBox控件</li>
<li>从关系数据库表中显示DataGrid对象中的数据</li>
<li>将Label连接到代表文件夹中文件数的整数</li>
</ul>
<p>使用内部WPF数据绑定引擎时，必须注意绑定操作的源和目标之间的区别。如您所料，数据绑定操作的<strong>源</strong>是数据本身（例如，布尔属性或关系数据），而<strong>目标</strong>是使用数据内容的UI控件属性（例如，CheckBox或TextBox控件）。</p>
<p>如前面的示例所述，除了绑定到传统数据外，WPF还支持元素绑定。这意味着您可以基于复选框的选中属性绑定（例如）属性的可见性。您当然可以在WinForms中执行此操作，但是必须通过代码来完成。WPF框架提供了一个丰富的数据绑定生态系统，几乎可以完全在标记中处理它。这也使您可以确保源和目标的值中的任何一个更改时都保持同步。</p>
<h4 id="构建数据绑定选项卡">构建数据绑定选项卡</h4>
<p>使用文档大纲编辑器，将第二个选项卡的网格更改为StackPanel。现在，使用Visual Studio的“工具箱”和“属性”编辑器来构建以下初始布局：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;TabItem</span> <span class="na">x:Name=</span><span class="s">&#34;tabDataBinding&#34;</span> <span class="na">Header=</span><span class="s">&#34;Data Binding&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel</span> <span class="na">Width=</span><span class="s">&#34;250&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">Content=</span><span class="s">&#34;Move the scroll bar to see the current value&#34;</span><span class="nt">/&gt;</span>
        <span class="c">&lt;!-- The scrollbar&#39;s value is the source of this data bind. --&gt;</span>
        <span class="nt">&lt;ScrollBar</span> <span class="na">x:Name=</span><span class="s">&#34;mySB&#34;</span> <span class="na">Orientation=</span><span class="s">&#34;Horizontal&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">Minimum =</span> <span class="s">&#34;1&#34;</span> <span class="na">Maximum =</span> <span class="s">&#34;100&#34;</span> <span class="na">LargeChange=</span><span class="s">&#34;1&#34;</span> <span class="na">SmallChange=</span><span class="s">&#34;1&#34;</span><span class="nt">/&gt;</span>
        <span class="c">&lt;!-- The label&#39;s content will be bound to the scroll bar! --&gt;</span>
        <span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;0&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/TabItem&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意，ScrollBar对象（在此处名为mySB）已配置为1到100之间的范围。目标是确保在重新放置滚动条的拇指（或单击向左或向右箭头）时，Label将自动用当前值更新。当前，Label控件的Content属性设置为值“0”；默认值为0。 但是，您将通过数据绑定操作来更改此设置。</p>
<h4 id="建立数据绑定">建立数据绑定</h4>
<p>可以在XAML中定义绑定的粘合剂是{Binding}标记扩展。尽管您可以通过Visual Studio定义绑定，但是直接在标记中进行操作同样容易。将名为labelSBThumb的Label的Content属性编辑为以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value, ElementName=mySB}&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>请注意分配给标签的内容属性的值。{Binding}语句表示数据绑定操作。<strong>ElementName</strong>值表示数据绑定操作的源（ScrollBar对象），而<strong>Path</strong>表示要绑定到的属性，在这种情况下为滚动条的Value。</p>
<p>如果再次运行程序，您会发现在移动拇指时，标签的内容会根据滚动条的值进行更新！</p>
<h4 id="datacontext属性">DataContext属性</h4>
<p>您可以使用另一种格式在XAML中定义数据绑定操作，在该格式中，可以通过将DataContext属性显式设置为绑定操作的源，从而突破{Binding}标记扩展所指定的值，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Breaking object/value apart via DataContext --&gt;</span>
<span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">DataContext =</span> <span class="s">&#34;{Binding ElementName=mySB}&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value}&#34;</span> <span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>在当前示例中，如果您要以这种方式修改标记，则输出将是相同的。鉴于此，您可能想知道何时要显式设置DataContext属性。这样做会有所帮助，因为子元素可以在标记树中继承其值。</p>
<p>这样，您可以轻松地将相同的数据源设置为一系列控件，而不必对多个控件重复一堆多余的“ {Binding ElementName = X，Path = Y}” XAML值。例如，假设您已将以下新按钮添加到此选项卡的StackPanel中（稍后您将看到为什么它如此之大）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">&#34;Click&#34;</span> <span class="na">Height=</span><span class="s">&#34;200&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>您可以使用Visual Studio为多个控件生成数据绑定，但是可以尝试使用XAML编辑器手动输入修改后的标记，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Note the StackPanel sets the DataContext property. --&gt;</span>
<span class="nt">&lt;StackPanel</span> <span class="na">Background=</span><span class="s">&#34;#FFE5E5E5&#34;</span> <span class="na">DataContext =</span> <span class="s">&#34;{Binding ElementName=mySB}&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Label</span> <span class="na">Content=</span><span class="s">&#34;Move the scroll bar to see the current value&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;ScrollBar</span> <span class="na">Orientation=</span><span class="s">&#34;Horizontal&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">Name=</span><span class="s">&#34;mySB&#34;</span> <span class="na">Maximum =</span> <span class="s">&#34;100&#34;</span> <span class="na">LargeChange=</span><span class="s">&#34;1&#34;</span> <span class="na">SmallChange=</span><span class="s">&#34;1&#34;</span><span class="nt">/&gt;</span>
    <span class="c">&lt;!-- Now both UI elements use the scrollbar&#39;s value in unique ways. --&gt;</span>
    <span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value}&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">Content=</span><span class="s">&#34;Click&#34;</span> <span class="na">Height=</span><span class="s">&#34;200&#34;</span> <span class="na">FontSize =</span> <span class="s">&#34;{Binding Path=Value}&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/StackPanel&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，您可以直接在StackPanel上设置DataContext属性。因此，当您移动拇指时，不仅会看到Label上的当前值，而且还会看到Button的字体大小根据相同的值相应地增大和缩小（图25-22显示了一种可能的输出）。</p>
<h4 id="格式化绑定数据">格式化绑定数据</h4>
<p>ScrollBar类型使用双精度表示拇指的值，而不是期望的整数（例如整数）。因此，当您拖动拇指时，您会在“标签”中找到各种浮点数（例如61.0576923076923）。 最终用户会发现这不太直观，因为他最有可能期望看到整数（例如61、62和63）。</p>
<p>如果要格式化数据，则可以添加ContentStringFormat属性，并传入自定义字符串和.NET格式说明符，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value}&#34;</span> <span class="na">ContentStringFormat=</span><span class="s">&#34;The value is: {0:F0}&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果格式说明中没有任何文本，则需要以空括号开头，这是XAML的例外顺序。例如，这使处理器知道下一个字符是文字​​，而不是绑定语句。这是更新的XAML：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value}&#34;</span> <span class="na">ContentStringFormat=</span><span class="s">&#34;{}{0:F0}&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意: 如果要绑定控件的Text属性，则可以在绑定语句中添加StringFormat名称/值对。对于内容属性，只需将其分开。</p>
</blockquote>
<h4 id="使用ivalueconverter进行数据转换">使用IValueConverter进行数据转换</h4>
<p>如果您需要做的不仅仅是格式化数据，还可以创建一个自定义类，该类实现System.Windows.Data命名空间的IValueConverter接口。此接口定义了两个成员，这些成员使您可以执行往返于目标和目的地的转换（在双向数据绑定的情况下）。定义此类后，可以使用它来进一步限定数据绑定操作的处理。</p>
<p>您可以使用值转换器在Label控件中显示整数，而不是使用format属性。为此，将一个新类（名为MyDoubleConverter）添加到项目类中。接下来，添加以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">class</span> <span class="nc">MyDoubleConverter</span> <span class="p">:</span> <span class="n">IValueConverter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">Convert</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Globalization</span><span class="p">.</span><span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Convert the double to an int.
</span><span class="c1"></span>        <span class="kt">double</span> <span class="n">v</span> <span class="p">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">ConvertBack</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Globalization</span><span class="p">.</span><span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// You won&#39;t worry about &#34;two-way&#34; bindings here, so just return the value.
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当值从源（ScrollBar）传输到目标（TextBox的Text属性）时，将调用Convert（）方法。您将收到许多传入的参数，但是您只需为此转换操作传入的对象，这是当前double的值。您可以使用此类型将类型转换为整数并返回新数字。</p>
<p>将值从目标传递到源时（如果启用了双向绑定模式），将调用ConvertBack（）方法。在这里，您只需直接返回值。 这样做可以让您在TextBox中输入浮点值（例如99.9），并在用户关闭控件时将其自动转换为整数值（例如99）。之所以发生这种“免费”转换，是因为在调用ConvertBack（）之后再次调用了Convert（）方法。如果仅从ConvertBack（）返回null，则绑定似乎不同步，因为文本框仍将显示浮点数。</p>
<p>要在标记中使用此转换器，首先必须创建一个本地资源，该资源代表刚构建的自定义类。不必担心增加资源的机制； 接下来的几章将更深入地探讨该主题。在打开的Window标记之后添加以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;local:MyDoubleConverter</span> <span class="na">x:Key=</span><span class="s">&#34;DoubleConverter&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来，将Label控件的绑定语句更新为以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="na">Content =</span> <span class="s">&#34;{Binding Path=Value,Converter={StaticResource DoubleConverter}}&#34;</span> <span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>现在，当您运行该应用程序时，您只会看到整数。</p>
<h4 id="在代码中建立数据绑定">在代码中建立数据绑定</h4>
<p>您也可以在代码中注册数据转换类。首先清理数据绑定选项卡中Label控件的当前定义，以使其不再使用{Binding}标记扩展名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;Label</span> <span class="na">x:Name=</span><span class="s">&#34;labelSBThumb&#34;</span> <span class="na">Height=</span><span class="s">&#34;30&#34;</span> <span class="na">BorderBrush=</span><span class="s">&#34;Blue&#34;</span> <span class="na">BorderThickness=</span><span class="s">&#34;2&#34;</span> <span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>确保System.Windows.Data有一个using；然后在窗口的构造函数中，调用一个名为SetBindings（）的新私有帮助器函数。在此方法中，添加以下代码（并确保从构造函数中调用它）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">SetBindings</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Create a Binding object.
</span><span class="c1"></span>    <span class="n">Binding</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Binding</span><span class="p">();</span>

    <span class="c1">// Register the converter, source, and path.
</span><span class="c1"></span>    <span class="n">b</span><span class="p">.</span><span class="n">Converter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyDoubleConverter</span><span class="p">();</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">mySB</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Path</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PropertyPath</span><span class="p">(</span><span class="s">&#34;Value&#34;</span><span class="p">);</span>
    
    <span class="c1">// Call the SetBinding method on the Label.
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">labelSBThumb</span><span class="p">.</span><span class="n">SetBinding</span><span class="p">(</span><span class="n">Label</span><span class="p">.</span><span class="n">ContentProperty</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数唯一看起来可能有点过时的部分是对SetBinding（）的调用。注意，第一个参数调用Label类的名为ContentProperty的静态只读字段。正如您将在本章稍后学习的那样，您将指定所谓的依赖项属性。就目前而言，只知道在代码中设置绑定时，第一个参数几乎总是需要您指定需要绑定的类的名称（在本例中为Label），然后调用基础属性后缀为Property的属性。无论如何，运行该应用程序都说明了Label仅打印出整数。</p>
<h4 id="构建数据网格选项卡">构建数据网格选项卡</h4>
<p>前面的数据绑定示例说明了如何配置两个（或多个）控件以参与数据绑定操作。尽管这很有用，但也可以从XML文件，数据库数据和内存中对象绑定数据。要完成此示例，您将设计选项卡控件的最终选项卡，以便它显示从AutoLot数据库的“库存”表获得的数据。</p>
<p>与其他选项卡一样，首先将当前的Grid更改为StackPanel。为此，可以使用Visual Studio直接更新XAML。现在，在新StackPanel中定义一个名为gridInventory的DataGrid控件，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;TabItem</span> <span class="na">x:Name=</span><span class="s">&#34;tabDataGrid&#34;</span> <span class="na">Header=</span><span class="s">&#34;DataGrid&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;DataGrid</span> <span class="na">x:Name=</span><span class="s">&#34;gridInventory&#34;</span> <span class="na">Height=</span><span class="s">&#34;288&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/TabItem&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>使用NuGet程序包管理器将实体框架添加到您的项目。接下来，右键单击该解决方案，选择“添加”➤“现有项目”，然后从第22章添加AutoLotDAL项目。从WpfControlsAndAPIs项目中添加对AutoLotDAL项目的引用。将连接字符串添加到App.config文件中。我的如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;connectionStrings&gt;</span>
    <span class="nt">&lt;add</span> <span class="na">name=</span><span class="s">&#34;AutoLotConnection&#34;</span> <span class="na">connectionString=</span><span class="s">&#34;data source=(LocalDb)\MSSQLLocalDB; initial catalog=AutoLot; integrated security=True;MultipleActiveResultSets=True; App=EntityFramework&#34;</span> <span class="na">providerName=</span><span class="s">&#34;System.Data.SqlClient&#34;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/connectionStrings&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>打开您的窗口的代码文件，并添加一个名为ConfigureGrid（）的最终帮助程序函数；确保从构造函数调用此函数。 假设您确实导入了AutoLotDAL命名空间，您所需要做的就是添加几行代码，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">AutoLotDAL.Repos</span><span class="p">;</span>
<span class="k">private</span> <span class="k">void</span> <span class="n">ConfigureGrid</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">repo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">InventoryRepo</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Build a LINQ query that gets back some data from the Inventory table.
</span><span class="c1"></span>        <span class="n">gridInventory</span><span class="p">.</span><span class="n">ItemsSource</span> <span class="p">=</span>
            <span class="n">repo</span><span class="p">.</span><span class="n">GetAll</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">Make</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">Color</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">PetName</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LINQ查询会创建一个新的匿名对象，该对象不包含Timestamp属性，因为对于用户而言，查看该字段没有任何价值。 如果要运行项目，则会看到数据填充网格。如果要使网格更加美观，可以使用Visual Studio属性窗口来编辑网格以使其更具吸引力。</p>
<p>总结了当前示例。在后面的章节中，您将看到其他一些正在使用的控件。但是，此时，您应该对在Visual Studio中构建UI以及手动使用XAML和C＃代码的过程感到满意。</p>
<h3 id="了解依赖属性的作用">了解依赖属性的作用</h3>
<p>像任何 .NET API一样，WPF使用 .NET 类型系统的每个成员（类，结构，接口，委托，枚举）和每个类型成员（属性，方法，事件，常量数据，只读字段等）。但是，WPF还支持称为<strong>依赖属性</strong>的独特编程概念。</p>
<p>就像“普通” .NET属性（在WPF文献中通常称为<strong>CLR属性</strong>）一样，可以使用XAML声明式设置或在代码文件中以编程方式设置依赖项属性。此外，依赖属性（如CLR属性）最终存在以封装类的数据字段，并且可以配置为只读，只写或读写。</p>
<p>使事情变得更有趣的是，几乎在每种情况下，您都会幸福地意识到实际上已设置（或访问）了一个依赖属性而不是CLR属性！ 例如，WPF控件从FrameworkElement继承的Height和Width属性以及从ControlContent继承的Content成员实际上都是依赖项属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="c">&lt;!-- Set three dependency properties! --&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">x:Name =</span> <span class="s">&#34;btnMyButton&#34;</span> <span class="na">Height =</span> <span class="s">&#34;50&#34;</span> <span class="na">Width =</span> <span class="s">&#34;100&#34;</span> <span class="na">Content =</span> <span class="s">&#34;OK&#34;</span><span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>鉴于所有这些相似之处，为什么WPF会为这种熟悉的概念定义一个新术语？答案在于在类中如何实现依赖项属性。您将很快看到一个编码示例；但是，从高层次来看，所有依赖项属性都是按以下方式创建的：</p>
<ul>
<li>首先，定义依赖项属性的类在其继承链中必须具有DependencyObject。</li>
<li>单个依赖项属性在DependencyProperty类型的类中表示为公共，静态，只读字段。按照惯例，通过在CLR包装器的名称后添加单词Property来命名该字段（请参见最后的要点）。</li>
<li>通过对DependencyProperty.Register（）的静态调用来注册DependencyProperty变量，该调用通常发生在静态构造函数中，或者在声明该变量时内联。</li>
<li>最后，该类将定义XAML友好的CLR属性，该属性将调用DependencyObject提供的方法以获取和设置值。</li>
</ul>
<p>一旦实现，依赖项属性将提供各种WPF技术所使用的许多强大功能，包括数据绑定，动画服务，样式，模板等。简而言之，依赖属性的动机是提供一种基于其他输入值来计算属性值的方法。下面列出了其中一些关键的好处，这些好处远远超出了使用CLR属性发现的简单数据封装的好处：</p>
<ul>
<li>依赖项属性可以从父元素的XAML定义继承其值。例如，如果您在窗口的开始标记中为FontSize属性定义了一个值，则默认情况下，该窗口中的所有控件的字体大小都相同。</li>
<li>依赖关系属性支持通过其XAML范围内包含的元素来设置值的功能，例如Button设置DockPanel父级的Dock属性。  （请记住，附加属性之所以能做到这一点，是因为附加属性是依赖属性的一种形式。）</li>
<li>依赖属性允许WPF基于多个外部值来计算一个值，这对于动画和数据绑定服务而言很重要。</li>
<li>依赖关系属性为WPF触发器提供基础结构支持（在处理动画和数据绑定时也经常使用）。</li>
</ul>
<p>现在请记住，在许多情况下，您将以与普通CLR属性相同的方式与现有的依赖项属性进行交互（这要归功于XAML包装器）。在上一节讨论了数据绑定的部分中，您看到了如果需要在代码中建立数据绑定，则必须在作为操作目标的对象上调用SetBinding（）方法，并指定它将操作的依赖项属性。像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">SetBindings</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Binding</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Binding</span><span class="p">();</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Converter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyDoubleConverter</span><span class="p">();</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">mySB</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Path</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PropertyPath</span><span class="p">(</span><span class="s">&#34;Value&#34;</span><span class="p">);</span>

    <span class="c1">// Specify the dependency property!
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">labelSBThumb</span><span class="p">.</span><span class="n">SetBinding</span><span class="p">(</span><span class="n">Label</span><span class="p">.</span><span class="n">ContentProperty</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在第27章的代码中检查如何启动动画时，将看到类似的代码。</p>
<p>唯一需要构建自己的自定义依赖项属性的时间是在编写自定义WPF控件时。例如，如果要构建定义四个自定义属性的UserControl，并且希望这些属性在WPF API中很好地集成，则应使用依赖项属性逻辑来编写它们。</p>
<p>具体来说，如果您的属性需要成为数据绑定或动画操作的目标，则该属性是否必须在更改后进行广播，是否必须能够以WPF样式用作Setter或是否必须能够要从父元素接收其值，普通的CLR属性是不够的。如果要使用普通的CLR属性，则其他程序员可能确实可以获取并设置一个值。但是，如果他们尝试在WPF服务的上下文中使用您的属性，则事情将无法按预期进行。因为您永远无法知道其他人可能如何与自定义UserControl类的属性进行交互，所以您应该养成在构建自定义控件时始终定义依赖项属性的习惯。</p>
<h4 id="检查现有的依赖项属性">检查现有的依赖项属性</h4>
<h3 id="概要-1">概要</h3>
<p>本章从控件工具包的概述和布局管理器（面板）的作用开始，研究了WPF控件的几个方面。第一个示例使您有机会构建一个简单的文字处理器应用程序，该应用程序说明了WPF的集成拼写检查功能，以及如何构建具有菜单系统，状态栏和工具栏的主窗口。</p>
<p>更重要的是，您研究了如何使用WPF命令。回想一下，您可以将这些不可知的事件附加到UI元素或输入手势，以自动继承现成的服务（例如剪贴板操作）。</p>
<p>您还学到了很多有关在XAML中构建复杂UI的知识，并且同时了解了WPF Ink API。您还收到了WPF数据绑定操作的介绍，包括如何使用WPF DataGrid类显示自定义AutoLot数据库中的数据。</p>
<p>最后，您研究了WPF如何对传统.NET编程原语（特别是属性和事件）施加独特的影响。如您所见，依赖项属性使您可以构建可以集成到WPF服务集（动画，数据绑定，样式等）中的属性。与此相关的是，路由事件为事件提供了一种在标记树上向上或向下流动的方式。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Single Long</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-12-03
      
        <a href="https://github.com/SLKyrim/myBlog/commit/0d326c5b174b157553f0bfbdd2a069c12bc552c8" title="Update Book_Pro_CSharp_7.md">
          (0d326c5)
        </a>
        
          <br>Update Book_Pro_CSharp_7.md
        
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://slkyrim.github.io/tags/c#/">C#</a>
          <a href="https://slkyrim.github.io/tags/wpf/">WPF</a>
          <a href="https://slkyrim.github.io/tags/copytranslator/">CopyTranslator</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/note_csharp_call_c_dll/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">WPF应用程序调用C编译生成的DLL动态链接库</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/book_reinforcement_learning/">
            <span class="next-text nav-default">《强化学习》(第2版)读书笔记</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "SLKyrim/comments-for-myBlog"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:623962644@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/SLKyrim" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://slkyrim.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Single Long
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
